"use strict";
               
var gdDomainName = "";

function gdDomainAddedUsrGrpMsg (domainName, mountName)
{
    return "Completed User/Group build.\n\n";
}

function gdDomainRemovedUsrGrpMsg (domainName, mountName)
{
    return "Completed User/Group removal.\n\n"+
           "* You will need to manually delete secrets from mount point '" + mountName + "'";
}
               
function trim(str, ch) {
    var start = 0, 
        end = str.length;

    while(start < end && str[start] === ch)
        ++start;

    while(end > start && str[end - 1] === ch)
        --end;

    return (start > 0 || end < str.length) ? str.substring(start, end) : str;
}
               
function cleanDN (dn)
{
    if (dn)
    {
        dn = trim(dn, ' ');
        dn = trim(dn, "\\")
        return dn.toUpperCase();
    }
    return '';
}

function domainUsersGroupsActionDialog ()
{   
    gdDomainAddedUsrGrpMsg ('1', '2');

    // check session
    var token = vaultToken();
    dbgTrace ("token = " + token);
    if (token == null)        
    {
        $("#createDomainUsersGroupsDialog").dialog('close');
        noteError ("Please Login before users/groups builder can be used.");
        return false;
    }          

    (async () => 
    {      
        var isRoot = await vault_HasRootAccess (VaultAddr, token);
        if (! isRoot)
        {   
            noteError ("Please Login with a ROOT token to use this feature!");
            return;
        }

        $("#createDomainUsersGroupsDialog").dialog({
                autoOpen: false,
                width: "auto",
                modal: false,
                title: "Add/Remove AD/LDAP User or Group to Vault",
                position: {of:       window,
                           my:       'center top',
                           at:       'center top+130',
                           collision:'none'
                          }, 
                close: function () 
                       { 
                           $(this).dialog("close");
                       }
        });        
        
        
        if (! $("#ugDomainNameOfEntity").val())
            $("#ugDomainNameOfEntity").val(gdDomainName);
        
        $("#createDomainUsersGroupsDialog").prev(".ui-dialog-titlebar").css("background-color","darkred");
        $("#createDomainUsersGroupsDialog").prev(".ui-dialog-titlebar").css("color","white");
        $("#createDomainUsersGroupsDialog").prev(".ui-dialog-buttonpane").css("background-color","darkred");        
        $("#createDomainUsersGroupsDialog").dialog('open');                  
    })();
}   


function dugOutput (l)
{    
    if (! l) { l = "" };
    $('#textarea_usersGroupsOutput').val($('#textarea_usersGroupsOutput').val() + "\n" + l);
    dbgInfo (l);
}

function dugGetGroupID (groupsList, groupName)
{
    // match groupName to get key ID
    for (var idx in groupsList["data"]["keys"])
    {
        var key = groupsList["data"]["keys"][idx];
        if (groupsList["data"]["key_info"][key].name == groupName)
        {
            return key;            
        }
    }           
    
    return null;
}

var VaultACLCommentHDR = '# Generated by Account Creation Vault GUI @ ';
function domainUsersGroupsAdd (domainName)
{
    // check session
    var token = vaultToken();
    dbgTrace ("token = " + token);
    if (token == null)        
    {
        $("#createDomainUsersGroupsDialog").dialog('close');
        noteError ("Please Login before users/groups builder can be used.");
        return false;
    }              
    
    domainName = cleanDN (domainName);
    if (domainName == "")
    {
        noteError ("Please Enter a NON-BLANK Domain name.");
        return false;        
    }    
    
    (async () => 
    {          
        var isGroup    = $('#ugGroupMode').is(':checked');
        var isUser     = $('#ugUserMode').is(':checked');
        var entityName = $('#ugNameOfEntity').val().trim().toLowerCase();
        var mountName  = $('#ugMountPointOfEntity').val().trim().toLowerCase();
        var createLDAPAuthLink = $('#ugAuthLDAP').is(':checked');
        var createOIDCAuthLink = $('#ugAuthOIDC').is(':checked');
       
        if (!isGroup && !isUser)
        {
            noteError ("Please select User/Group type radio button!");
            return;
        }
        
        if (entityName == "")
        {
            noteError ("Please enter a User or Group!");
            return;            
        }
        
        if (mountName == "")
            mountName = entityName;
            
        var isRoot = await vault_HasRootAccess (VaultAddr, token);
        if (! isRoot)
        {   
            noteError ("Please Login with a ROOT token to use this feature!");
            return;
        }
        
        dugOutput ("---------------------------------------------------");
               
        // Check auth systems are in place
        var ldapAccessor = null;
        var oidcAccessor = null;
        try { ldapAccessor = authList["ldap/"]["accessor"]; } catch { };
        try { oidcAccessor = authList["oidc/"]["accessor"]; } catch { };
        
        if (createOIDCAuthLink && !oidcAccessor)
        {
            var m = "Unable to continue, oidc authentication method not present!";
            dugOutput (m);
            noteError (m);            
            return;            
        }
        
        if (createLDAPAuthLink && !ldapAccessor)
        {
            var m = "Unable to continue, ldap authentication method not present!";
            dugOutput (m);
            noteError (m);            
            return;            
        }
        
        // Obtain the group list 
        var groupsListURL = VaultAddr + '/v1/identity/group/id?list=true';
        var groupsList = await fetch(groupsListURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                    }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + groupsListURL); return null; });
        if (! groupsList)
        {
            var m = "Failed to load group list!'";
            noteError (m);
            dugOutput (m);
            dugOutput ("Unable to continue, please resolve issue!");
            return;
        }

        dbgTrace ("domainUsersGroupsAdd policies List " + JSON.stringify(groupsList,null,'    '));
       
        // Create/Update the policy 
        var policyURL = VaultAddr + '/v1/sys/policies/acl/' + entityName;
        var policyData = await fetch(policyURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + policyURL); return null; });

        var ts = new Date().toISOString();
        var policyCreateUpdate = { "name" : mountName, "policy" : "" };
        var pHDR = VaultACLCommentHDR + ts + '\n';
        var p    = 'path "' + mountName + '/*" { capabilities = ["create", "read", "update", "delete", "list"] }\n'+  
                   'path "' + mountName + '" { capabilities = ["deny"] }';  
        var updatePolicy = true;
                 
        if (! policyData || (policyData && ("errors" in policyData))) // Create a new policy 
        {
            policyCreateUpdate["policy"] = pHDR + p;            
            dugOutput ("Creating new policy '" + entityName +"'");
            dugOutput (pHDR + p);
        }
        else if (! policyData["data"]["policy"].includes(p))      // update policy if it does not already exists 
        {
            policyCreateUpdate["policy"] = policyData["data"]["policy"] + '\n' + pHDR + p;
            dugOutput ("Updating existing policy '" + entityName +"'");
            dugOutput (pHDR + p);
        }
        else
        {
            dugOutput ("Bypassing policy build, existing policy '" + entityName +"' already contains this process's ACL");
            updatePolicy = false;
        }

        if (updatePolicy)
        {
            var submitPolicyData = await fetch(policyURL, { method: 'PUT', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                            , body:   JSON.stringify(policyCreateUpdate)
                                                          }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + policyURL); return false; });

            if (submitPolicyData)
            {
                dugOutput ("Policy updated '" + entityName +"' successfully");
            }
            else
            {
                var m = "Policy create/update '" + entityName +"' failed!";
                dugOutput (m);
                dugOutput ("Unable to continue, please resolve issue!");
                noteError (m);
                return;
            }
        }
        
        // Obtain the authentication types id         
        var authListURL = VaultAddr + '/v1/sys/auth';        
        var authList = await fetch(authListURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + authListURL); return null; });
        if (! authList)
        {
            var m = "Failed loading authentication accessors!";
            dugOutput (m);
            dugOutput ("Unable to continue, please resolve issue!");
            noteError (m);            
            return;
        }

        // ========================= CREATE User ====================================
        if (isUser) 
        {
            // Look up user identity 
            var entityLookupURL      = VaultAddr + "/v1/identity/lookup/entity";    
            var entityCreateURL      = VaultAddr + "/v1/identity/entity";
            var entityCreateAliasURL = VaultAddr + "/v1/identity/entity-alias";
            var ldapEntityName       = entityName;
            var entityID             = null;
            var entityLDAP = await fetch(entityLookupURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                            , body:   JSON.stringify({"alias_name" : ldapEntityName, "alias_mount_accessor" :  ldapAccessor })
                                                          }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + entityLookupURL); return null; });
                                        
            var oidcEntityName = domainName + "\\" + entityName;
            var entityOIDC = await fetch(entityLookupURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                            , body:   JSON.stringify({"alias_name" : oidcEntityName, "alias_mount_accessor" :  oidcAccessor })
                                                          }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + entityLookupURL); return null; });
                                        
            if (entityLDAP)
            {
                // dbgInfo ("Matched entity ldap " + ldapEntityName + " : " + JSON.stringify(entityLDAP,null,'    ')); 
                dugOutput ("Matched existing LDAP entity alias " + ldapEntityName);
                entityID = entityLDAP["data"]["id"];
            }
                                        
            if (entityOIDC && createOIDCAuthLink)
            {               
                if (entityID && (entityID != entityOIDC["data"]["id"]))
                {
                    dugOutput ("ISSUE: Matched LDAP & OIDC entity alias don't match the same entity ID, resyncing to a signle entity id...");
                    var delOIDCURL= VaultAddr + '/v1/identity/entity/id/' + entityOIDC["data"]["id"];
                    var delOIDC = await fetch(delOIDCURL, { method: 'DELETE', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                          }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + entityLookupURL); return false; });
                    if (! delOIDC)
                    {
                        var m = "Failed to purge OIDC unsynced alias '" + entityOIDC["data"]["id"] + "'";
                        dugOutput (m);
                        noteError (m);
                        dugOutput ("ISSUE: Resync failed! Unable to continue.");
                        return;
                    }
                    entityOIDC = null;  // create the link for this entity and entityID's differ between alias                
                }
                else
                {
                    dugOutput ("Matched existing OIDC entity alias " + oidcEntityName);
                    entityID = entityOIDC["data"]["id"];
                }
            }

            // if no entity, create one ...   
            if (!entityID)
            {            
                
                var newEntityName = "_" + entityName + "_";
                dugOutput ("Entity not found, creating new user '" + newEntityName +"'");
                var newEntity = await fetch(entityCreateURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                               , body:   JSON.stringify({"name" : newEntityName, "disabled" :  "false" })
                                                             }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + entityCreateURL); return null; });
                if (! newEntity)
                {
                    var m = "Failed to create new entity  '" + newEntityName + "'";
                    dugOutput (m);
                    noteError (m);
                    dugOutput ("ISSUE: New Entity failed! Unable to continue.");
                    return;
                }                
                entityID = newEntity["data"]["id"];
            }            

            if (createLDAPAuthLink)
            {
                if (!entityLDAP)
                {
                    // create LDAP entity                 
                    dugOutput ("Creating new LDAP alias '" + ldapEntityName + "' to entity ID '" + entityID + "'");
                    entityLDAP = await fetch(entityCreateAliasURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                                     , body:   JSON.stringify({"name" : ldapEntityName, "canonical_id" : entityID, "mount_accessor" :  ldapAccessor })
                                                                   }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + entityCreateAliasURL); return null; });            
                    if (! entityLDAP)
                    {
                        var m = "Failed to create new entity LDAP alias '" + ldapEntityName + "' for ID '" + entityID + "'";
                        dugOutput (m);
                        noteError (m);
                        dugOutput ("ISSUE: New Entity LDAP alias failed! Unable to continue.");
                        return;
                    }                                                        
                }
            }
            
            if (createOIDCAuthLink)
            {                
                if (!entityOIDC)
                {
                    // create OIDC entity                 
                    dugOutput ("Creating new OIDC alias '" + oidcEntityName + "' to entity ID '" + entityID + "'");
                    entityOIDC = await fetch(entityCreateAliasURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                                     , body:   JSON.stringify({"name" : oidcEntityName, "canonical_id" : entityID, "mount_accessor" :  oidcAccessor })
                                                                   }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + entityCreateAliasURL); return null; });
                    if (! entityOIDC)
                    {
                        var m = "Failed to create new entity OIDC alias '" + oidcEntityName + "' for ID '" + entityID + "'";
                        dugOutput (m);
                        noteError (m);
                        dugOutput ("ISSUE: New Entity OIDC alias failed! Unable to continue.");
                        return;
                    }                                           
                } 
            }
            
            // match groupName to get key ID
            var groupInfo = null;
            var groupName =  "BASE\\" + entityName;
            groupID = dugGetGroupID (groupsList, groupName);
            
            // Load BASE\enity name 
            if (groupID)
            {
                var getGroupURL = VaultAddr + '/v1/identity/group/id/' + groupID;
                groupInfo   = await fetch(getGroupURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                       }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + getGroupURL); return null; });    
            }
            
            if (!groupInfo)
            {
                // Create new group 
                dugOutput ("Creating new user base group '" + groupName + "' for entity '" + entityID + "'");
                var newGroupURL  = VaultAddr + '/v1/identity/group';                
                var newGroup = await fetch(newGroupURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                          , body:   JSON.stringify({"name" : groupName, "type":"internal","policies":[ entityName ],  "member_entity_ids" : [ entityID ] })
                                                        }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + newGroupURL); return false; });
                if (! newGroup)
                {
                    var m = "Failed to create user BASE group '" + groupName + "' for entity '" + entityID + "'";
                    dugOutput (m);
                    noteError (m);
                    dugOutput ("ISSUE: New Entity BASE group creation failed! Unable to continue.");
                    return;
                }
            }
            else
            {   
                dugOutput ("Updating existing user BASE group '" + groupName + "' for entity '" + entityID + "'");        
                
                if ( (! groupInfo["data"].hasOwnProperty("member_entity_ids") || (groupInfo["data"].hasOwnProperty("member_entity_ids") && (groupInfo["data"]["member_entity_ids"] == null))) )
                    groupInfo["data"]["member_entity_ids"] = [];                
                
                groupInfo["data"]["member_entity_ids"].push(entityID);
                var updGroupURL = VaultAddr + '/v1/identity/group/id/' + groupInfo["data"]["id"];                
                var updGroup = await fetch(updGroupURL, { method: 'POST', headers: { "x-vault-token" : token } , cache: 'no-cache'
                                                          , body:   JSON.stringify({"member_entity_ids" : groupInfo["data"]["member_entity_ids"] })
                                                        }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + updGroupURL); return false; });

                if (! updGroup)
                {
                    var m = "Failed updating existing user BASE group '" + groupName + "' for entity '" + entityID + "'";        
                    dugOutput (m);
                    noteError (m);
                    dugOutput ("ISSUE: New Entity BASE group creation failed! Unable to continue.");
                    return;
                }                 
            }
            
            dugOutput ("User '" + entityName + "' has been linked/created as '" + groupName + "' to LDAP and OIDC authenticate methods");
        }
        else  // ========================= CREATE Group ====================================
        {           
            // Look up group id
            var groupLookupURL      = VaultAddr + "/v1/identity/lookup/group";    
            var groupCreateURL      = VaultAddr + "/v1/identity/group";
            var groupCreateAliasURL = VaultAddr + "/v1/identity/group-alias";
            var groupName           = entityName;
            var ldapGroupName       = groupName;
            var groupID             = null;
            var groupLDAP = await fetch(groupLookupURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                          , body:   JSON.stringify({"alias_name" : ldapGroupName, "alias_mount_accessor" :  ldapAccessor })
                                                        }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + groupLookupURL); return null; });
                                        
            var oidcGroupName = domainName + "\\" + groupName;
            var groupOIDC = await fetch(groupLookupURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                          , body:   JSON.stringify({"alias_name" : oidcGroupName, "alias_mount_accessor" :  oidcAccessor })
                                                        }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + groupLookupURL); return null; });
                                        
            if (groupLDAP)
            {
                dugOutput ("Matched existing LDAP group alias " + ldapGroupName);
            }
                                        
            if (groupOIDC && createOIDCAuthLink)
            {
                dugOutput ("Matched existing OIDC group alias " + oidcGroupName);               
            }

            if (createLDAPAuthLink)
            {
                // if no group, create one ...   
                if (! groupLDAP)
                {            
                    var newGroupName = "LDAP\\" + groupName;                    
                    var groupLDAPID  = dugGetGroupID (groupsList, newGroupName);
                    if (! groupOIDCID)
                    {
                        dugOutput ("Creating new LDAP group '" + newGroupName + "'");
                        groupLDAP = await fetch(groupCreateURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                                  , body:   JSON.stringify({"name" : newGroupName, "type" :  "external" })
                                                                }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + groupCreateURL); return null; });
                        if (! groupLDAP)
                        {
                            var m = "Failed creating new LDAP group " + newGroupName;
                            dugOutput (m);
                            noteError (m);                        
                            dugOutput ("ISSUE: Creating new LDAP group failed! Unable to continue.");
                            return;
                        }                
                                                
                        groupLDAPID = groupLDAP["data"]["id"];
                    }
                    
                    // Create group alias 
                    dugOutput ("Creating new LDAP group alias '" + newGroupName + "' to auth id '" + groupLDAPID + "'");                    
                    var newGroupAlias = await fetch(groupCreateAliasURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                                           , body:   JSON.stringify({"name" :  groupName, "canonical_id" :  groupLDAPID, "mount_accessor": ldapAccessor })
                                                                         }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + groupCreateAliasURL); return null; });
                    if (! newGroupAlias)
                    {
                        var m = "Failed creating new LDAP group alias '" + newGroupName + "' to auth id '" + groupLDAPID + "'";
                        dugOutput (m);
                        noteError (m);
                        dugOutput ("ISSUE: Creating new LDAP group alias to auth id failed! Unable to continue.");
                        return;
                    } 
                }            
            }
            
            if (createOIDCAuthLink)
            {                
                if (!groupOIDC)
                {                                       
                    var newGroupName = "OIDC\\" + groupName;                    
                    var groupOIDCID  =  dugGetGroupID (groupsList, newGroupName);
                    if (! groupOIDCID)
                    {
                        dugOutput ("Creating new OIDC group '" + newGroupName + "'");
                        groupOIDC = await fetch(groupCreateURL, { method: 'POST', headers: { "x-vault-token" : token } , cache: 'no-cache'
                                                                  , body:   JSON.stringify({"name" : newGroupName, "type" :  "external" })
                                                                }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + groupCreateURL); return null; });
                        if (! groupOIDC)
                        {
                            var m = "Failed creating new OIDC group " + newGroupName;
                            dugOutput (m);
                            noteError (m);                        
                            dugOutput ("ISSUE: Creating new OIDC group failed! Unable to continue.");
                            return;
                        }     
                        groupOIDCID = groupOIDC["data"]["id"];
                    }
                    
                    // Create group alias 
                    var newGroupAliasName = domainName + "\\"  + groupName;
                    dugOutput ("Creating new OIDC group alias '" + newGroupAliasName + "' to auth id '" + groupOIDCID + "'");
                    var newGroupAlias = await fetch(groupCreateAliasURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                                           , body:   JSON.stringify({"name" :  newGroupAliasName, "canonical_id" :  groupOIDCID, "mount_accessor": oidcAccessor })
                                                                         }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + groupCreateAliasURL); return null; });
                    if (! newGroupAlias)
                    {
                        var m = "Failed creating new OIDC group alias '" + newGroupAliasName + "' to auth id '" + groupOIDCID + "'";
                        dugOutput (m);
                        noteError (m);
                        dugOutput ("ISSUE: Creating new OIDC group alias to auth id failed! Unable to continue.");
                        return;
                    }                                          
                } 
            }
            
            // match groupName to get key ID
            var groupInfo = null;
            groupName =  "BASE\\" + entityName;
            groupID = dugGetGroupID (groupsList, groupName);            
            // Load BASE\enity name 
            if (groupID)
            {
                var getGroupURL = VaultAddr + '/v1/identity/group/id/' + groupID;
                groupInfo   = await fetch(getGroupURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                       }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + getGroupURL); return null; });    
            }
            
            if (!groupInfo)
            {
                var mbrsGroupID = [];
                                
                if (createLDAPAuthLink)
                    mbrsGroupID.push(groupLDAP["data"]["id"]);

                if (createOIDCAuthLink)
                    mbrsGroupID.push(groupOIDC["data"]["id"]);
                 
                // Create new group 
                dugOutput ("Creating new base group '" + groupName + "'");
                var newGroupURL  = VaultAddr + '/v1/identity/group';
                var newGroup = await fetch(newGroupURL, { method: 'POST', headers: { "x-vault-token" : token } , cache: 'no-cache'
                                                          , body:   JSON.stringify({"name" : groupName, "type":"internal","policies":[ entityName ],  "member_group_ids" : mbrsGroupID })
                                                        }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + newGroupURL); return false; });
                if (! newGroup)
                {
                    var m = "Failed creating new base group '" + groupName + "'";
                    dugOutput (m);
                    noteError (m);                                            
                    dugOutput ("ISSUE: Failed to create new base group '" + groupName + "'! Unable to continue");
                    return;
                }
            }
            else
            {           
                if ( (! groupInfo["data"].hasOwnProperty("member_group_ids") || (groupInfo["data"].hasOwnProperty("member_group_ids") && (groupInfo["data"]["member_group_ids"] == null))) )
                    groupInfo["data"]["member_group_ids"] = [];
                    
                if (createLDAPAuthLink)                          
                    groupInfo["data"]["member_group_ids"].push(groupLDAP["data"]["id"]);
                
                if (createOIDCAuthLink)
                    groupInfo["data"]["member_group_ids"].push(groupOIDC["data"]["id"]);
                          
                dugOutput ("Updating existing base group '" + groupName + "'");
                var updGroupURL = VaultAddr + '/v1/identity/group/id/' + groupInfo["data"]["id"];                
                var updGroup = await fetch(updGroupURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                          , body:   JSON.stringify({"member_group_ids" : groupInfo["data"]["member_group_ids"] })
                                                        }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + updGroupURL); return false; });
                                        
                if (! updGroup)
                {
                    var m = "Failed updating existing base group '" + groupName + "'";
                    dugOutput (m);
                    noteError (m);
                    dugOutput ("ISSUE: Failed updating existing base group '" + groupName + "'! Unable to continue");
                    return;
                }                 
            }

            dugOutput ("Group '" + entityName + "' has been linked/created as '" + groupName + "' to LDAP and OIDC authenticate methods");
        }


        // Obtain mount point        
        var mountListURL = VaultAddr + '/v1/sys/internal/ui/mounts';        
        var mountList = await fetch(mountListURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                  }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + mountListURL); return null; });
        if (! mountList)
        {
            var m = "Failed loading Mount list!";
            dugOutput (m);
            dugOutput ("Unable to continue, please resolve issue!");
            noteError (m);            
            return;
        }

        if (! (mountName+"/" in  mountList["data"]["secret"]) )        
        {
            dugOutput ("Creating new Mount '" + mountName + "'...");            
            var newMountURL = VaultAddr + '/v1/sys/mounts/' + mountName;                
            var mountData = await fetch(newMountURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                       , body:   JSON.stringify({"path": mountName,"type":"kv","config":{},"options":{"version":2},"generate_signing_key":"true"})
                                                     }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + newMountURL); return false; });
            if (! mountData)
            {
                var m = "Failed Mount creation of '" + mountName + "'!";
                dugOutput (m);
                dugOutput ("Unable to continue, please resolve issue!");
                noteError (m);            
                return;
            }                                                    
        }
        else
        {
            dugOutput ("Mount '" + mountName + "' already exists.");
        }

        var m =  gdDomainAddedUsrGrpMsg (domainName, mountName);
        dugOutput (m);       
        noteNorm (m.replaceAll("\n", "<br>"));
    })();
}

function domainUsersGroupsRemoveConfirm (domainName)
{
    var entityName = $('#ugRemoveNameOfEntity').val().trim().toLowerCase();
    var mountName  = $('#ugRemoveMountPointOfEntity').val().trim().toLowerCase();
          
    domainName = cleanDN (domainName)
    if (domainName == "")
    {
        noteError ("Please Enter a NON-BLANK Domain name.");
        return false;        
    }
    
    if (entityName == "")
    {
        noteError ("Please enter a User or Group to remove!");
        return;            
    }
    
    if (mountName == "")
        mountName = entityName;
    
    let t = 'Confirm removal of access of ' + $('#ugRemoveNameOfEntity').val() + ' from mount point ' + $('#ugRemoveMountPointOfEntity').val();
    $.when( confirmRemoveOperation (t, $("#createDomainUsersGroupsDialog") ).then(function(status) 
    {
        status = status.toLowerCase();
        if (status == "yes")
        {            
            domainUsersGroupsRemove (domainName);
        }
    }));      
}

function domainUsersGroupsRemove (domainName)
{    
    // check session
    var token = vaultToken();
    dbgTrace ("token = " + token);
    if (token == null)        
    {
        $("#createDomainUsersGroupsDialog").dialog('close');
        noteError ("Please Login before users/groups builder can be used.");
        return false;
    }     
    domainName = cleanDN (domainName)
    if (domainName == "")
    {
        noteError ("Please Enter a NON-BLANK Domain name.");
        return false;        
    }

    (async () => 
    {         
        var entityName = $('#ugRemoveNameOfEntity').val().trim().toLowerCase();
        var mountName  = $('#ugRemoveMountPointOfEntity').val().trim().toLowerCase();
              
        if (entityName == "")
        {
            noteError ("Please enter a User or Group to remove!");
            return;            
        }
        
        if (mountName == "")
            mountName = entityName;
    
        var isRoot = await vault_HasRootAccess (VaultAddr, token);
        if (! isRoot)
        {   
            noteError ("Please Login with a ROOT token to use this feature!");
            return;
        }
        
        dugOutput ("---------------------------------------------------");    
                
        // Check auth systems are in place
        var ldapAccessor = null;
        var oidcAccessor = null;
        try { ldapAccessor = authList["ldap/"]["accessor"]; } catch { };
        try { oidcAccessor = authList["oidc/"]["accessor"]; } catch { };
        
        if (createOIDCAuthLink && !oidcAccessor)
        {
            var m = "Unable to continue, oidc authentication method not present!";
            dugOutput (m);
            noteError (m);            
            return;            
        }
        
        if (createLDAPAuthLink && !ldapAccessor)
        {
            var m = "Unable to continue, ldap authentication method not present!";
            dugOutput (m);
            noteError (m);            
            return;            
        }
        
        // Obtain the group list 
        var groupsListURL = VaultAddr + '/v1/identity/group/id?list=true';
        var groupsList = await fetch(groupsListURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                    }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed request on " + groupsListURL); return null; });
        if (! groupsList)
        {
            var m = "Failed to load group list!'";
            noteError (m);
            dugOutput (m);
            dugOutput ("Unable to continue, please resolve issue!");
            return;
        }

        // Obtain the authentication types id         
        var authListURL = VaultAddr + '/v1/sys/auth';        
        var authList = await fetch(authListURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed request on " + authListURL); return null; });
        if (! authList)
        {
            var m = "Failed loading authentication accessors!";
            dugOutput (m);
            dugOutput ("Unable to continue, please resolve issue!");
            noteError (m);            
            return;
        }

        dbgTrace ("domainUsersGroupsRemove policies List " + JSON.stringify(groupsList,null,'    '));
       
        // Create/Update the policy 
        var policyURL = VaultAddr + '/v1/sys/policies/acl/' + entityName;
        var policyData = await fetch(policyURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed request on " + policyURL); return null; });

        var ts = new Date().toISOString();
        var acl1 = ' path "' + mountName + '/*" { capabilities = ["create", "read", "update", "delete", "list"] }';
        var acl2 = ' path "' + mountName + '" { capabilities = ["deny"] }';
        var updatePolicy = false;
        var deletePolicy = false;
                                 
        if (! policyData || (policyData && ("errors" in policyData))) // Policy does not exist
        {
            dugOutput ("Failed loading ACL policy '" + entityName + "', so deleting it anyway.");
            deletePolicy = true; // delete policy, though it probably does not exist
        }
        else
        {
            let rACL1 = gfEscapeRegExp(acl1).replaceAll(' ', '\\s*');
            dbgTrace ("\nBEFORE ACL1: " + rACL1);
            dbgTrace (policyData["data"]["policy"]);            
            
            dugOutput ("Matching ACL policy '" + entityName + "' to '" + acl1 + "'");
            policyData["data"]["policy"] = policyData["data"]["policy"].replaceAll(new RegExp (rACL1, 'gm'), '');
            
            let rACL2 = gfEscapeRegExp(acl2).replaceAll(' ', '\\s*');
            dbgTrace ("\nBEFORE ACL2: " + rACL2);
            dbgTrace (policyData["data"]["policy"]);                        
            dugOutput ("Matching ACL policy '" + entityName + "' to '" + acl2 + "'");
            policyData["data"]["policy"] = policyData["data"]["policy"].replaceAll(new RegExp (rACL2, 'gm'), '');
            
            let rHDR = ('^\\s*' + gfEscapeRegExp(VaultACLCommentHDR) + '.*').replaceAll(' ', '\\s*');
            dbgTrace ("\nBEFORE VaultACLCommentHDR: " + rHDR);
            dbgTrace (policyData["data"]["policy"]);                                    
            
            dugOutput ("Matching ACL policy '" + entityName + "' to '" + VaultACLCommentHDR + "'");
            policyData["data"]["policy"] = policyData["data"]["policy"].replaceAll(new RegExp (rHDR, 'gm'), '');
            
            dbgTrace ("\nBefore Comments : ");
            dbgInfo (policyData["data"]["policy"]);                                    
            
            // remove any comments that exist in updated policy, and test for anything that is left as ACL code
            var testPolicy = policyData["data"]["policy"];
            testPolicy = testPolicy.replaceAll(new RegExp('^\\s*#.*', 'gm'), '').trim(); 

            dbgTrace ("\nBefore Test : ");
            dbgTrace (testPolicy);                                    

            if (testPolicy == "") 
            {            
                deletePolicy = true;
                dugOutput ("Matched ACL policy '" + entityName + "' and removed it, remainder of policy is blank, so deleting it anyway.");
            }
            else
            {
                updatePolicy = true;
                dugOutput ("Matched ACL policy '" + entityName + "' tried to remove ACL, updating remainder of policy");
                dugOutput ("=>" + policyData["data"]["policy"] + "<=");
            }
        }
        
        if (updatePolicy)
        {    
            var submitPolicyData = await fetch(policyURL, { method: 'PUT', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                            , body:   JSON.stringify(policyCreateUpdate)
                                                          }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed update on " + policyURL); return false; });

            if (submitPolicyData)
            {
                dugOutput ("Policy updated '" + entityName +"' successfully");
            }
            else
            {
                var m = "Policy update '" + entityName +"' failed!";
                dugOutput (m);
                dugOutput ("Unable to continue, please resolve issue!");
                noteError (m);
                return;
            }    
        }
        
        if (deletePolicy)
        {
            var delOK = await fetch(policyURL, { method: 'DELETE', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                               }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed delete on " + policyURL); return false; });

            if (delOK)
            {
                dugOutput ("Policy delete '" + entityName +"' successfully");
            }
            else
            {
                var m = "Policy delete '" + entityName +"' failed!";
                dugOutput (m);
                dugOutput ("Unable to continue, please resolve issue!");
                noteError (m);
                return;
            }
        }

        // *** load entity ID, if it exists ***
        var entityLookupURL      = VaultAddr + "/v1/identity/lookup/entity";    
        var ldapEntityName  = entityName;        
        var entityLDAPid    = null;
        var entityOIDCid    = null;
        var entityLDAP = await fetch(entityLookupURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                        , body:   JSON.stringify({"alias_name" : ldapEntityName, "alias_mount_accessor" :  ldapAccessor })
                                                      }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + entityLookupURL); return null; });
                                    
        var oidcEntityName = domainName + "\\" + entityName;
        var entityOIDC = await fetch(entityLookupURL, { method: 'POST', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                        , body:   JSON.stringify({"alias_name" : oidcEntityName, "alias_mount_accessor" :  oidcAccessor })
                                                      }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsAdd: Error failed request on " + entityLookupURL); return null; });
                                    
        if (entityLDAP)
        {
            // dbgInfo ("Matched entity ldap " + ldapEntityName + " : " + JSON.stringify(entityLDAP,null,'    ')); 
            dugOutput ("Matched existing LDAP entity alias " + ldapEntityName);
            entityLDAPid = entityLDAP["data"]["id"];
        }
        
        if (entityOIDC)
        {
            // dbgInfo ("Matched entity ldap " + ldapEntityName + " : " + JSON.stringify(entityLDAP,null,'    ')); 
            dugOutput ("Matched existing OIDC entity alias " + oidcEntityName);
            entityOIDCid = entityOIDC["data"]["id"];            
        }
            
        if ((! entityLDAPid) && (! entityOIDCid))
        {
            dugOutput("Entity '" +  entityName +"' does not exist as a user, expecting it exists as a group");
        }
               
       
        // match groupName to get key ID
        var groupDelList = ["LDAP\\" + entityName, "OIDC\\" + entityName, "BASE\\" + entityName];
        
        for (var grpIdx = 0; grpIdx < groupDelList.length; grpIdx++)
        {
            var groupInfo = null;
            var groupName = groupDelList[grpIdx];
            var groupID = dugGetGroupID (groupsList, groupName);
            var groupLDAPid = dugGetGroupID (groupsList, "LDAP\\" + entityName);
            var groupOIDCid = dugGetGroupID (groupsList, "OIDC\\" + entityName);
                            
            if (groupID) // if group exists, then remove entity and group alias from the group, and update/delete as required.
            {
                var getGroupURL = VaultAddr + '/v1/identity/group/id/' + groupID;
                groupInfo   = await fetch(getGroupURL, { method: 'GET', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                       }).then(response => response.json()).then(data => { return data; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed request on " + getGroupURL); return null; });
               
               // Fix up null or non-existing dictionary keys
               if ( (! groupInfo["data"].hasOwnProperty("member_entity_ids") || (groupInfo["data"].hasOwnProperty("member_entity_ids") && (groupInfo["data"]["member_entity_ids"] == null))) )
                    groupInfo["data"]["member_entity_ids"] = []; 
                
               if ( (! groupInfo["data"].hasOwnProperty("member_group_ids") || (groupInfo["data"].hasOwnProperty("member_group_ids") && (groupInfo["data"]["member_group_ids"] == null))) )
                    groupInfo["data"]["member_group_ids"] = []; 
                                
               if ( (! groupInfo["data"].hasOwnProperty("policies") || (groupInfo["data"].hasOwnProperty("policies") && (groupInfo["data"]["policies"] == null))) )
                    groupInfo["data"]["policies"] = []; 
                
                
                // remove entity ids from group.
                if (groupInfo["data"]["member_entity_ids"].length > 0)
                {
                    // remove entity ids 
                    for( var i = 0; i < groupInfo["data"]["member_entity_ids"].length; i++)
                    {                 
                        if ((groupInfo["data"]["member_entity_ids"][i] === entityOIDCid) || (groupInfo["data"]["member_entity_ids"][i] === entityLDAPid)) 
                        {                 
                            dugOutput ("Removing from group '" + groupName + "' entity id '" + groupInfo["data"]["member_entity_ids"][i] + "'");
                            groupInfo["data"]["member_entity_ids"].splice(i, 1); 
                            i--; // retest at this index
                        }                
                    }                
                }                           
 
                // remove accessor groups IDs from group
                if (groupInfo["data"]["member_group_ids"].length > 0)
                {
                    // remove entity ids 
                    for( var i = 0; i < groupInfo["data"]["member_group_ids"].length; i++)
                    {                 
                        if ((groupInfo["data"]["member_group_ids"][i] === groupLDAPid) || (groupInfo["data"]["member_group_ids"][i] === groupOIDCid)) 
                        {             
                            dugOutput ("Removing from group '" + groupName + "' group id '" + groupInfo["data"]["member_group_ids"][i] + "'");
                            groupInfo["data"]["member_group_ids"].splice(i, 1); 
                            i--; // retest at this index
                        }                
                    }                
                }           
                            
                // remove policies 
                if (deletePolicy)
                {                                
                    if (groupInfo["data"]["policies"].length > 0)
                    {
                        // remove entity ids 
                        for( var i = 0; i < groupInfo["data"]["policies"].length; i++)
                        {                 
                            if (groupInfo["data"]["policies"][i] === entityName) 
                            {                 
                                dugOutput ("Removing from group '" + groupName + "' policy '" + groupInfo["data"]["policies"][i] + "'");
                                groupInfo["data"]["policies"].splice(i, 1); 
                                i--; // retest at this index
                            }                
                        }                
                    }           
                }
                         
                // Determine if BASE group needs to updated of deleted!
                if ((groupInfo["data"]["member_group_ids"].length <= 0) && (groupInfo["data"]["member_entity_ids"].length <= 0)) 
                {
                    var delGroupURL = VaultAddr + '/v1/identity/group/id/' + groupID;
                    delOK   = await fetch(delGroupURL, { method: 'DELETE', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                       }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed delete on " + delGroupURL); return false; });
                    if (! delOK)
                    {
                         dugOutput ("Failed to delete group '" + groupName + "'");
                    }
                    else
                    {
                        dugOutput ("Deleted group '" + groupName + "'");
                    }
                }
                else
                {                
                    dugOutput ("Removed access on entity '" + entityName + "' from group '" + groupName + "' but there is still other users/groups active for this group!");
                    
                    if (deletePolicy)
                    {                        
                        dugOutput ("INFO : policy '" + entityName+ "' was removed from the group '" + groupName + "'");    
                    }
                    if (groupInfo["data"]["policies"].length <= 0)
                    {
                        dugOutput ("WARNING! : group '" + groupName + "' has no policies. Group will not be able access secrets within Vault!");    
                    }
                    
                    dugOutput ("Updating group '" + groupName + "'");
                    
                    var updateGroupURL = VaultAddr + '/v1/identity/group/id/' + groupID;
                    var updateOK       = await fetch(updateGroupURL, { method: 'PUT', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                                       , body:   JSON.stringify(groupInfo["data"])
                                                                     }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed update on " + updateGroupURL); return false; });
                                                                                                                
                    if (! updateOK)
                    {
                        dugOutput ("Failed to update group '" + groupName + "'");
                    }                                                      
               }
                
            }        
            else
            {
                if ((! entityLDAPid) && (! entityOIDCid))
                {
                    dugOutput ("Failed to match to group '" + groupName + "', may already have been removed?");
                }
            }
        }
        
        
        var entityDelList = [entityLDAPid, entityOIDCid];
        
        for (var entIdx = 0; grpIdx < entityDelList.length; entIdx++)
        {
            if (! entityDelList[entIdx])
                continue;

             var delEntityURL = VaultAddr + '/v1/identity/entity/id/' + entityDelList[entIdx];
             var delOK   = await fetch(delGroupURL, { method: 'DELETE', headers: { "x-vault-token" : token }, cache: 'no-cache'
                                                    }).then(data => { if ([200, 201, 202, 204].includes(data.status)) return true; else return false; }).catch((error) => { dbgError  ("domainUsersGroupsRemove: Error failed delete on " + delEntityURL); return false; });
             if (delOK)
             {
                 dugOutput ("Deleted entity id '" + entityDelList[entIdx] + "' matched to entity name '" + entityName + "'");
             }
             else
             {
                 dugOutput ("Failed to deleted entity id '" + entityDelList[entIdx] + "' matched to entity name '" + entityName + "'");
             }
        } 

        var m =  gdDomainRemovedUsrGrpMsg (domainName, mountName);
        dugOutput (m);       
        noteNorm (m.replaceAll("\n", "<br>"));        
    })();
}
