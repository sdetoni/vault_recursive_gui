<html>
<head>
<!-- This Vault recursive search was written by Steven De Toni, Oct 2020 -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Pragma" content="no-cache">
<title>Vault</title>
    <!-- Icon Library -->
    <link rel="stylesheet" href="fontawesome/css/all.min.css">

    <!-- jQuery & UI -->
    <script src="jquery-ui-1.12.1/external/jquery/jquery.js"></script>
    <link rel="stylesheet" href="jquery-ui-1.12.1/jquery-ui.css">
    <script src="jquery-ui-1.12.1/jquery-ui.min.js"></script>

    <!-- combobox widget -->
    <script src="jquery-ui-combobox/combobox.js"></script>
    <link   rel="stylesheet" href="jquery-ui-combobox/combobox.css">

    <!-- JSTree Lib -->
    <link rel="stylesheet" href="jstree/themes/default/style.min.css">
    <script src="jstree/jstree.min.js"></script>

    <!-- Pretty print source code -->
    <script src="js_libs/run_prettify.js"></script>

    <!-- Recursive Search Functions and Styles -->
    <script src="js_libs/gen_funcs.js"></script>
    <script src="js_libs/debug.js"></script>
    <script src="js_libs/vault_group_buldr_funcs.js"></script>
    <script src="js_libs/vault_export_import_json.js"></script>
    <link rel="stylesheet" href="css/search.css">
<script defer type="text/javascript">
"use strict";

const AUTHOR                = '<u>Vault Javascript GUI Helper</u><br><br>Written by <b>Steven De Toni</b><br>for the<br>University of Waikato<br><br>2021';
const FLDRCHR               = '/';       // char used to separate a vault secrets path (e.g. systems/SMS-Keepass-Database/LoadBalancer)
const DefaultPage           = "/ui";
const FrameID               = "vaultIFrame";
const VaultBaseGUIURI       = "/vault/secrets";
const VaultAuthURI          = "/vault/auth?with=oidc";
const SelectMenuLabelBrk    = '\t';
var Cryptoe                 = new gfCryptStdCrypto(); Cryptoe.init(16,64);
var VaultCacheMaxAgeMinutes = 4*60;        // 4 hour before auto expire of cache objects, and auto cache loading (if enabled) becomes active
var VaultCacheRefreshMinutes= 30;          // every 30 mins refresh cache objects
var VaultAPICache           = { };
var VaultChkTime            = 1000 * 30; // 30 seconds
var VaultAsyncChkLoadTime   = 1000 * 5;  // 5 seconds
var VaultAbortSearch        = false;     // Cancel current search operation
var AsyncCacheEnabled       = true;      // determines if async cache loading is enabled
var SearchRecycleBinEnabled = false;     // determines if search will search ~RecycleBin~ folders in vault as well?
var VaultGUIHideCubby       = false;     // hide the cubby section as its most noise...
var VaultAddr               = window.location.protocol + "//" + location.host;
var VaultRecycleBinPath     = "~RecycleBin~";
var ALLOFVAULT              = "All of Vault";

window.onload = function(event)
{
    gfShowPage (DefaultPage + VaultAuthURI);
};

function vaultDumpDict (d, depth=0)
{
    for (var k in d)
    {
        if (typeof(d[k]) == "object")
        {
            dbgInfo ((Array(depth).fill('    ').join('')) + k);
            vaultDumpDict (d[k], depth+1);
        }
        else
            dbgInfo ((Array(depth).fill('    ').join('')) + k + ':' + d[k]);
    }
}

function getVaultEmberObj ()
{
    var emberVaultArry = null;
    // Loop jumping loading Ember Obj/Env
    try {         
        emberVaultArry = document.getElementById(FrameID).contentWindow.requireModule('ember')['default'].Namespace.NAMESPACES;       
        //dbgInfo ("emberVaultArry [step 1], Load Success = " + (emberVaultArry != null))
        if (!emberVaultArry)
        {
            emberVaultArry = document.getElementById(FrameID).contentWindow.Ember.Namespace.NAMESPACES;
            //dbgInfo ("emberVaultArry [step 1.1], Load Success =" + (emberVaultArry != null))
        }
    } catch {    
        try 
        {
            emberVaultArry = document.getElementById(FrameID).contentWindow.Ember.Namespace.NAMESPACES;
            //dbgInfo ("emberVaultArry [step 2], Load Success =" + (emberVaultArry != null))
        } catch (err) {       
            emberVaultArry = null;
        }
    }   
    
    // var emberVaultArry = document.getElementById(FrameID).contentWindow.Ember.Namespace.NAMESPACES;       
    var emberVaultObj  = null;
    if (emberVaultArry != null)
    {
        for (var i=0; i < emberVaultArry.length; i++)
        {
            try
            {
                if (emberVaultArry[i].modulePrefix.toLowerCase() == "vault")
                {
                    // dbgInfo ("Matched ember vault namespace!");
                    emberVaultObj = emberVaultArry[i];
                    break;
                }
            }
            catch {  }
        }
    }
    else
        dbgError ("emberVaultArry failed loading of Ember Env!")   
   
    if (!emberVaultObj)
        dbgError ("emberVaultObj failed loading of Ember Obj!")   

    return emberVaultObj;
}

function vaultToken ()
{
    let token = null;

    try
    {
        let emberVaultObj = getVaultEmberObj();
	    token = emberVaultObj.__container__.lookup("service:auth").currentToken;

        if ((token != null) && (token != "") && (emberVaultObj.__container__.lookup("service:auth").tokenExpired))
        {
            clrReqCache();
            token = null;
        }
    } catch {
        clrReqCache();
        token = null;
    }

    return token;
}

function vaultIsFolderPath (path)
{
    return path.endsWith(FLDRCHR);
}

function vaultMakeDeepLinkURL (uri)
{
    return  VaultAddr + window.location.pathname + '?goto=' + escape(uri);
}

function vaultDoDeepLinkURL (uri)
{
    var u = vaultMakeDeepLinkURL(uri); 
    gfCopyToClipboard(u);  
    noteNorm( String.fromCharCode(39)+ u + String.fromCharCode(39) + " copied into clipboard");
}

function vaultUIGotoURI (uri, closeDialog=true, reEncodeURL=true)
{
    var gotoURL = unescape(uri);

    // Vault EMBER magic code to redirect to the correct page
    if (reEncodeURL)
        gotoURL = gfURLEncode(gotoURL);

    dbgInfo ("vaultUIGotoURI: " + gotoURL);
    
    try
    {
        // v1.16 and before
        var r = getVaultEmberObj().__container__.lookup("controller:application").transitionToRoute ( gotoURL );
        r.followRedirects();
    }
    catch(err)
    {
        // v1.17 change 
        var r = getVaultEmberObj().__container__.lookup("controller:application").target.transitionTo ( gotoURL );
        r.followRedirects();
    }
    
    VaultCurrentURL = "";

    try { ThisSrchResultsDialogBox.dialog("close"); } catch(err) { }
}

function refreshGotoURI (uri)
{
    location = vaultMakeDeepLinkURL (uri);
}

function vaultUIGotoPath (secretNamePath)
{
    if (secretNamePath != "")
    {
        var baseName = secretNamePath.split(FLDRCHR)[0] + FLDRCHR;
        var basePath = secretNamePath.split(FLDRCHR).slice(1).join(FLDRCHR);

        // Build URL if path is a leaf node (no ending '/' char) and 'show' action,
        // otherwise its a folder path and 'list' action
        if (vaultIsFolderPath(basePath))
            vaultUIGotoURI (VaultBaseGUIURI + FLDRCHR + baseName + 'list' + FLDRCHR + basePath);
        else if (basePath == "")
            vaultUIGotoURI (VaultBaseGUIURI + FLDRCHR + baseName + 'list');
        else // v1.18.x change 
        {
            let u = VaultBaseGUIURI + FLDRCHR + baseName + 'kv' + FLDRCHR + escape(escape(basePath).replaceAll('/', '%2F')) + '/details';
            dbgInfo ("vaultUIGotoPath (details): " +u);
            vaultUIGotoURI (u, true, false);
        }
    }
    else
        vaultUIGotoURI (VaultBaseGUIURI);
}

function vaultParentPath (secretNamePath)
{
    if (secretNamePath != "")
    {
        var baseName = secretNamePath.split(FLDRCHR)[0] + FLDRCHR;
        var basePath = secretNamePath.split(FLDRCHR).slice(1).join(FLDRCHR);
        var list = gfRStrip(basePath, FLDRCHR).split(FLDRCHR);

        basePath = list.slice(0, list.length-1).join(FLDRCHR);
        if (basePath != "")
            basePath += FLDRCHR;
        return baseName + basePath;
    }
    return secretNamePath;
}

function vaultUIGotoParentPath (secretNamePath)
{
    vaultUIGotoPath(vaultParentPath (secretNamePath));
}

function vaultActionStartEnd (actionEnded=false)
{
    if (actionEnded)
    {
        VaultAbortSearch = true;
        $(".search-action").prop("disabled", false);
        $(".search-busy").css("display", "none");
        $("#search-buts").css("display","");
    }
    else
    {
        // Show pacifier to user show work in progress...
        VaultAbortSearch = false;
        $(".search-action").prop("disabled", true);
        $(".search-busy").css("display", "");
        $("#search-buts").css("display","none");
    }
}

function vaultAbortAction ()
{
    vaultActionStartEnd (true);
    noteError ('Action Stopped Prematurely!');
    return false;
}

function vault_generateCodeExample (apiURL)
{
    var username = getVaultEmberObj().__container__.lookup("service:auth").authData.displayName;
    apiURL = gfURLEncode(unescape(apiURL));
    dbgInfo ("vault_generateCodeExample: " + apiURL);
    dbgInfo ("vault_generateCodeExample: " + username);

    var regex = /(.*?)\/v1\/(.*?\/)data\/(.*)/;
    var grpMatch = apiURL.match(regex);
    if (! grpMatch)
    {
        noteError ("Bad Mojo in vault_generateCodeExample on data '" + apiURL + "'");
        return;
    }

    var serverURL = grpMatch[1];
    var scrtName  = grpMatch[2];
    var scrtPath  = grpMatch[3];

    // Load the code example template code, and replace it with current parameters
    var code = $.ajax({type: "GET",
                       url: "example_template.html",
                       async: false
                     }).responseText;

    code = code.replaceAll("%SERVER-URL%",  serverURL);
    code = code.replaceAll("%API-URL%",     apiURL);
    code = code.replaceAll("%USERNAME%",    username);
    code = code.replaceAll("%SECRET-PATH%", scrtName + 'data/' + scrtPath);
    code = code.replaceAll("%SCRT-NAME%",   scrtName);
    code = code.replaceAll("%SCRT-PATH%",   scrtPath);

    $("#codeGenSrcDialog").html (code);
    var h = (window.innerHeight / 100) * 90;
    var w = (window.innerWidth  / 100) * 90;
    var d = $("#codeGenSrcDialog").dialog({ maxHeight: h,
                                            maxWidth:  w,
                                            width:     'auto',
                                            autoOpen:  false,
                                            modal:     false,
                                            show:      'fold',
                                            hide:      'fold',
                                            show: {effect: 'fade', duration: 50},
                                            hide: {effect: 'fade', duration: 50},
                                            position: {of:       window,
                                                       my:       'center top',
                                                       at:       'center top',
                                                       collision:'none'
                                                      }
                                        });



    // hack to insert icons
    d.data( "uiDialog" )._title = function(title)
                                 {
                                     title.html( this.options.title );
                                 };

    var cpyJSONCall = "gfCopyToClipboard($('#codeGenSrcDialog').text()); noteNorm('Example Access Vault Secrets API Code copied to Clipboard')";
    var icon = '<button style="margin-right:5px;" onclick="' + cpyJSONCall + '; return false;"  type="button" class="ui-button ui-corner-all ui-widget ui-button-icon-only custom-title-button" title="Copy to Clipboard">' +
               '<span class="ui-icon ui-icon-copy"></span><span class="ui-button-icon-space"></span>Copy to Clipboard</button>';

    // syntax colour code output
    PR.prettyPrint();

    // insert icon and title text
    d.dialog('option', 'title', icon + 'Example Access Vault Secrets API Code');
    d.dialog('open');
}

function noteNorm (msg, showTime=3000)
{
    $("#userNoteNorm").html(msg);
    // $("#userNoteNorm").css("bottom", "30px");
    $("#userNoteNorm").css("top", "33%");
    $("#userNoteNorm").hide().fadeIn(500);

    setTimeout(function() {
         $("#userNoteNorm").fadeOut(500);

     }, showTime);
}

function noteError (msg, showTime=3500)
{
    gfBeep();
    $("#userNoteErr").html(msg);
    $("#userNoteErr").css("top", "33%");
    $("#userNoteErr").hide().fadeIn(500);

    setTimeout(function() {
         $("#userNoteErr").fadeOut(500);

     }, showTime);
}

function vault_apiURLtoPath (apiURL)
{
/* *******************
if url matches /v1/<base name>/metadata/<path>?list then
    path = vault/secrets/<base name>/list/<path>

else if url matches /v1/<base name>/data/<path> then
    path = vault/secrets/<base name>/<path>
else
    path = vault/secrets/<base name>/show/<path>
******************** */
    let regex = /(.*?)\/v1\/(.*?)\/metadata\/(.*)(\?list.*)/;
    let grpMatch = apiURL.match(regex)
    if (grpMatch)
    {
        // Check/construct url is a leaf node, and so will have a 'show' action
        if ((grpMatch[3] != '') && (grpMatch[3].slice(-1) != FLDRCHR))
            return apiURL.replace(regex, '/vault/secrets/$2/show/$3');

        // folder url (end with '/') have a 'list' action
        return apiURL.replace(regex, '/vault/secrets/$2/list/$3');
    }

    regex = /(.*?)\/v1\/(.*?)\/data\/(.*)/;
    let m = apiURL.match(regex);
    if (m)
    {
        // v 1.18.x changed how secret info is linked in the rest api url
        return  apiURL.replace(regex, '/vault/secrets/$2/kv/' + m[3].replaceAll('/', '%2F') + '/details');
    }

    return apiURL.replace(/(.*?)\/v1\/(.*?)\/(.*)/, '/vault/secrets/$2/show/$3');
}

function vault_pathURLtoNamePath (vaultPathURL)
{
    var name = "";
    var path = "";

    var regex = "/vault/secrets/(.*/)(kv/list)/(.*)";
    var matchNamePath = vaultPathURL.match(regex);
    if (matchNamePath)
    {        
        name = matchNamePath[1];
        path = matchNamePath[3];
        if (path == "/")
            path = "";
        dbgTrace ("vault_pathURLtoNamePath(1): name : >" + name + "< path: >" + path + "<");
        return [name, path];
    }
    
    var regex = "/vault/secrets/(.*/)(kv(/?))(.*?)(/)(list$|show$|directory$|metadata$|paths$|metadata/versions$|details(\\??version.*)$)";
    var matchNamePath = vaultPathURL.match(regex);
    if (matchNamePath)
    {      
        name = matchNamePath[1];
        path = matchNamePath[4];
        if (path == "/")
            path = "";
        dbgTrace ("vault_pathURLtoNamePath(2): name : >" + name + "< path: >" + path + "<");
        return [name, path];
    }
     
    var regex = "/vault/secrets/(.*/)(kv/)(.*)";
    var matchNamePath = vaultPathURL.match(regex);
    if (matchNamePath)
    {    
        name = matchNamePath[1];
        path = matchNamePath[3];
        dbgTrace ("vault_pathURLtoNamePath(3): name : >" + name + "< path: >" + path + "<");
        return [name, path];
    }        
    
    var regex = "/vault/secrets/(.*/)(list|show)/(.*)";
    var matchNamePath = vaultPathURL.match(regex);
    if (matchNamePath)
    {    
        name = matchNamePath[1];
        path = matchNamePath[3];
        dbgTrace ("vault_pathURLtoNamePath(4): name : >" + name + "< path: >" + path + "<");
        return [name, path];
    }

    regex             = "/vault/secrets/(.*/)list";
    var matchBaseName = vaultPathURL.match(regex);
    if (matchBaseName)
    {
        name = matchBaseName[1];
        dbgTrace ("vault_pathURLtoNamePath(5): name : >" + name + "< path: >" + path + "<");
        return [name, path];
    }

    dbgTrace ("vault_pathURLtoNamePath(6): name : >" + name + "< path: >" + path + "<");
    return [name, path];
}

function nodeShowAdminIcons (id)
{
    (async () =>
    {
        dbgInfo ("nodeShowMenu: " + id);
        $('#' + id + '_1').css("display", "none");
        $('#' + id + '_2').css("display","contents");
    })();
}

function vault_makeFolderLink (text, id, isEndFolder, apiURL, secretVersion, secretName, secretPath)
{
    var s = "";
    s += "<a title='Goto Vault Item' class='fas fa-link vgoto-link1'      onclick='vaultUIGotoURI(\"" + escape(vault_apiURLtoPath (apiURL)) + "\", true, false);' href='#'></a>&nbsp;";

    s += "<a id='" + id + "_1" + "'  title='Admin Features' class='fas fa-angle-double-right vgoto-link1' onclick='nodeShowAdminIcons(\"" + id + "\");' href='#'>&nbsp;</a>";
    s += "<span  id='" + id + "_2" + "' class='stree-admenu'>";    
    s += "<a title='Copy Deep Link URL Folder Path into Clipboard' class='fas fa-external-link-alt vgoto-link1' onclick='vaultDoDeepLinkURL (\"" + escape(secretName+secretPath) + "\");' href='#'></a>&nbsp;"; 
    s += "<a title='Copy Folder Name into Clipboard' class='far fa-copy vgoto-link1' onclick='gfCopyToClipboard(\"" + escape(text) + "\");noteNorm( String.fromCharCode(39)+ \"" + escape(text) + "\" +  String.fromCharCode(39) + \" copied into clipboard\");' href='#'></a>&nbsp;";       
    s += "<a title='Clone/Move/Rename Folder' class='fas fa-folder vgoto-link1' onclick='cloneMoveActionDialog (\"" + escape(secretName + secretPath) + "\");' href='#'></a>&nbsp;";

    if (isEndFolder)
    {
        s += "<a title='Generate Example Vault Access Code' class='fas fa-laptop-code vgoto-link1' onclick='vault_generateCodeExample(\"" + escape(apiURL) + "\");' href='#'></a>&nbsp;";
    }

    s += "<a title='Delete Item'     class='fas fa-trash-alt vgoto-link1' onclick='nodeDeleteItem(this,\"" + escape(secretName + secretPath) + "\",\"single\");' href='#'></a>";
    s += "&nbsp;</span>";
    s += "<span class='stree-folder'>&nbsp;&nbsp;" + text + "</span>";
    return s;
}

function nodeClipboardCopy (key, id)
{
    (async () =>
    {
        var d = $('#searchOutput').jstree(true).get_node(id);
        gfCopyToClipboard(await Cryptoe.decrypt(d.data));
        noteNorm('<span style="font-size:large;font-weight:bold">' + unescape(key) + '</span><br>data copied into clipboard');
    })();
}

function nodeShowSecret (id)
{
    (async () =>
    {
        var id_1 = '#' + id + '_1';
        var id_2 = '#' + id + '_2';
        dbgInfo ("nodeShowSecret: " + id);
        if ($(id_1).hasClass("no-show-secret"))
        {
            var d = $('#searchOutput').jstree(true).get_node(id);
            // dbgInfo ("nodeShowSecret: Encrypt " + d.data);
            $(id_2).html('<pre>' + (await Cryptoe.decrypt(d.data)).replaceAll('<', '&lt;').replaceAll('>', '&gt;')  + '</pre>');
            $(id_1).removeClass("no-show-secret");
        }
        else
        {
            $(id_2).html("");
            $(id_1).addClass("no-show-secret");
        }
    })();
}

async function vault_makeEndNodeLink (text, id, data, apiURL)
{
    return await (async () =>
    {
        var s = "";
        s += "<a title='Copy Secret to Clipboard'       class='far fa-copy vcopy-link' onclick='nodeClipboardCopy(\"" + escape(text) + "\", \"" + id + "\");' href='#'></a>";
        s += "<a id='" + id + "_1" + "' title='Show Secret' class='no-show-secret vgoto-link2' onclick='nodeShowSecret(\"" + id + "\");' href='#'>";
        s += "&nbsp;<span class='stree-endnode'>" + text + "</span></a><span onclick='nodeClipboardCopy(\"" + escape(text) + "\", \"" + id + "\");'  id='" + id + "_2" + "' class='stree-pwd'/>";
        return s;
    })();
}

var vault_jsTreeDictNum = 0;
async function vault_jsTreeSearchDict (d, idPref='treesrh', depth=0)
{
    return await (async () =>
    {
        var rtnData = [];
        if (depth == 0)
            vault_jsTreeDictNum = 0;

        for (var k in d)
        {
            if (d[k]["child"] != null)
            {
                // dbgTrace ((Array(depth).fill('    ').join('')) + k);
                var node = { };
                var label = k;

                if (label.match('\$'))
                    label = gfRStrip(label, FLDRCHR);

                if (d[k]["isEndFolder"])
                    node["icon"] = "jstree-file";

                vault_jsTreeDictNum++;
                node["name"]     = k;
                node["id"]       = (idPref + vault_jsTreeDictNum);
                node["text"]     = vault_makeFolderLink (label, node["id"], d[k]["isEndFolder"], d[k]["apiURL"], d[k]["scrtVersion"], d[k]["scrtName"], d[k]["scrtPath"]);
                node["state"]    = {"opened":true};
                node["children"] = await vault_jsTreeSearchDict (d[k]["child"], idPref, depth+1);
                node["data"]     = d[k];
                rtnData.push(node);
            }
            else
            {
                // dbgTrace ((Array(depth).fill('    ').join('')) + k + ':' + d[k]);
                var node = { };
                vault_jsTreeDictNum++;
                node["name"]   = k;
                node["id"]     = (idPref + vault_jsTreeDictNum);
                if (d[k]["isLeafNode"])
                    node["text"] = await vault_makeEndNodeLink (k, node["id"], d[k]["data"], d[k]["apiURL"]);
                else
                    node["text"] = vault_makeFolderLink (k, node["id"], d[k]["isEndFolder"], d[k]["apiURL"], d[k]["scrtVersion"], d[k]["scrtName"], d[k]["scrtPath"]);
                node["type"]   = "leaf-node";
                node["data"]   = d[k]["data"];
                node["state"]  = {"opened":true, "checkbox_disabled":true };
                rtnData.push(node);
            }
        }
        return rtnData;
    })();
}

function vault_jsTreeAllDict (d, openAllState=true, pathToUnfold='', idPref='treeall', depth=0)
{
    var rtnData = [];
    if (depth == 0)
        vault_jsTreeDictNum = 0;

    // Parse out the left most path item to match and open on jstree
    var pathList   = gfRStrip(pathToUnfold, FLDRCHR).split(FLDRCHR);
    var labelMatch = pathList[0];
    pathToUnfold   = pathList.splice(1).join(FLDRCHR);
    
    for (var k in d)
    {
        if (d[k]["child"] != null)
        {
            // dbgTrace ((Array(depth).fill('    ').join('')) + k);
            var node = { };
            var label = k;

            if (label.match('\$'))
                label = gfRStrip(label, FLDRCHR);

            if (d[k]["isEndFolder"])
                node["icon"] = "jstree-file";

            vault_jsTreeDictNum++;
            node["text"]     = "<span class='stree-folder'>" + label + "</span>";
            node["name"]     = k;
            node["id"]       = (idPref + vault_jsTreeDictNum);
            if (label == labelMatch)
                node["state"] = {"opened":true};
            else
                node["state"] = {"opened":openAllState};
            node["children"] = vault_jsTreeAllDict (d[k]["child"], openAllState, pathToUnfold, idPref, depth+1);
            node["data"]     = d[k];
            rtnData.push(node);
        }
        else
        {
            // dbgTrace ((Array(depth).fill('    ').join('')) + k + ':' + d[k]);
            var node = { };
            vault_jsTreeDictNum++;
            node["text"]   = "<span class='stree-endnode'>" + k + "</span>";
            node["name"]   = k;
            node["id"]     = (idPref + vault_jsTreeDictNum);
            
            if (k == labelMatch)
                node["state"] = {"opened":true};
            else
                node["state"] = {"opened":openAllState};
                
            node["type"]   = "leaf-node";
            node["data"]   = d[k]["data"];
            rtnData.push(node);
        }
    }
    return rtnData;
}

function vault_jsTreeFolderDict (d, openAllState=true, pathToUnfold='', idPref='treefld', depth=0)
{
    var rtnData = [];
    if (depth == 0)
        vault_jsTreeDictNum = 0;

    // Parse out the left most path item to match and open on jstree
    var pathList   = gfRStrip(pathToUnfold, FLDRCHR).split(FLDRCHR);
    var labelMatch = pathList[0];
    pathToUnfold   = pathList.splice(1).join(FLDRCHR);
    
    for (var k in d)
    {
        if (d[k]["child"] != null)
        {
            // dbgTrace ((Array(depth).fill('    ').join('')) + k);
            var node  = { };
            var label = k;

            if (label.match('\$'))
                label = gfRStrip(label, FLDRCHR);

            vault_jsTreeDictNum++;
            node["text"]     = "<span class='stree-folder'>" + label + "</span>";
            node["name"]     = k;
            node["id"]       = (idPref + vault_jsTreeDictNum);
            
            if (label == labelMatch)
                node["state"] = {"opened":true};
            else
                node["state"] = {"opened":openAllState};
                
            node["children"] = vault_jsTreeFolderDict (d[k]["child"], openAllState, pathToUnfold, idPref, depth+1);
            node["data"]     = d[k];

            if (d[k]["isEndFolder"])
                node["type"]   = "leaf-node";

            rtnData.push(node);
        }
        else
        {
            // dbgTrace ((Array(depth).fill('    ').join('')) + k + ':' + d[k]);
            var node = { };
            vault_jsTreeDictNum++;
            node["text"]   = "<span class='stree-endnode'>" + k + "</span>";
            node["name"]   = k;
            node["id"]     = (idPref + vault_jsTreeDictNum);
            
            if (k == labelMatch)
                node["state"] = {"opened":true};
            else
                node["state"] = {"opened":openAllState};

            node["type"]   = "leaf-node";
            node["data"]   = d[k]["data"];
            rtnData.push(node);
        }
    }
    return rtnData;
}

// Filter out properties (encrypted data)
function vault_dumpSearchTreeToJSONFilter (key, value)
{
    if (['data'].includes(key))
        return '*** ENCRYPTED ***';
    return value;
}

// used more for debugging than anything more useful.
function vault_dumpSearchTreeToJSON (d)
{
    var s = JSON.stringify(d, vault_dumpSearchTreeToJSONFilter, 4);

    $("#dumpSearchTreeToJSONOutput").html ("<pre class='prettyprint lang-json'>" + s + "</pre>");
    var h = (window.innerHeight / 100) * 90;
    var w = (window.innerWidth  / 100) * 90;
    var d = $("#dumpSearchTreeToJSONDialog").dialog({
                                maxHeight: h,
                                maxWidth:  w,
                                width:     'auto',
                                autoOpen:  false,
                                modal:     false,
                                show:      'fold',
                                hide:      'fold',
                                show: {effect: 'fade', duration: 50},
                                hide: {effect: 'fade', duration: 50},
                                position: {of:       window,
                                           my:       'left top',
                                           at:       'left top+50',
                                           collision:'none'
                                          }

                            });

    // hack to insert icons
    d.data( "uiDialog" )._title = function(title)
                                 {
                                     title.html( this.options.title );
                                 };

    var cpyJSONCall = "gfCopyToClipboard($('#dumpSearchTreeToJSONOutput').text()); noteNorm('JSON Export copied to Clipboard');";
    var icon = '<button  style="margin-right:5px;" onclick="' + cpyJSONCall + '; return false;"  type="button" class="ui-button ui-corner-all ui-widget ui-button-icon-only custom-title-button" title="Copy to Clipboard">' +
               '<span class="ui-icon ui-icon-copy"></span><span class="ui-button-icon-space"> </span>Copy to Clipboard</button>';

    // syntax colour code output
    PR.prettyPrint();

    $("#dumpSearchTreeToJSONDialog").prev(".ui-dialog-titlebar").css("background-color","darkblue");
    $("#dumpSearchTreeToJSONDialog").prev(".ui-dialog-titlebar").css("color","white");

    // insert icon and title text
    d.dialog('option', 'title', icon + 'JSON Search (debugging) Output');
    d.dialog('open');
}

var VaultAPIPending = { };

// ======================================= Start of vaultbulkloader Insert =========================================

function submitVaultAPIRequest (token, url, clrCacheOnError=false, vaultAPIPendingDict=null)
{
    let uobj = {clrCacheOnError:clrCacheOnError, promise:null};

    if (vaultAPIPendingDict)
        vaultAPIPendingDict[url] = uobj;
    else
        VaultAPIPending[url] = uobj;

    // start async loading of url
    // dbgTrace ("submitVaultAPIRequest submit : " + url);
    uobj.promise = fetch(url, { method: 'GET'
                               , headers: { "x-vault-token" : token,
                                            "Connection"    : "keep-alive"
                                          }
                               , cache: 'no-cache'
                        })
                        .then(response => response.json())
                        .then(data => {
                            // dbgTrace ("submitVaultAPIRequest: adding VaultAPICache " + url);
                            addReqCache (url, data, vaultAPIPendingDict);
                            return true;
                        })
                        .catch((error) => {
                                if (uobj.clrCacheOnError)
                                    clrReqCache();
                                dbgError  ("submitVaultAPIRequest: Error failed request on " + url);
                                dbgError  ("submitVaultAPIRequest: " + error);
                                removeVaultAPIRequest(url, vaultAPIPendingDict);
                                return false;
                        });
}

async function waitAllVaultAPIRequest ()
{
    while (Object.keys(VaultAPICache).length > 0)
    {
        await new Promise(s => setTimeout(s, 1));
    }
}

function removeVaultAPIRequest (url, vaultAPIPendingDict=null)
{
    if (vaultAPIPendingDict)
        delete vaultAPIPendingDict[url];
    else
        delete VaultAPIPending[url];
}

async function getReqCache (url)
{
    return await (async () =>
    {
        const interrupt = 1;
        const timeOut   = (1000/interrupt)*30;
        var  urlWaited = false;
        var  urlLoaded = false;

        if (url.match("^http.*"))
        {
            // Wait time for current URL to complete and be loaded into cache! max time approx 30 seconds if the 16ms timer is honoured
            for (var i = 0; i < timeOut; i++)
            {
                let uobj = VaultAPIPending[url];
                if (! uobj)
                {
                    if (urlWaited)
                        urlLoaded = true;
                    // dbgTrace ("getReqCache: ubj null  " + url);
                    break;
                }

                // if attached promise, then block/wait until its completed...
                if (uobj.promise)
                {
                    urlWaited = true;
                    // dbgTrace ("getReqCache: waiting for " + url);
                    await uobj.promise;
                }

                // release cpu in this thread of execution to allow item to be removed from VaultAPIPending, and placed into VaultAPICache
                await new Promise(s => setTimeout(s, interrupt));
            }

            if (i >= timeOut)
                dbgError ("getReqCache: timeOut on '" + url + "'");
        }

        let fnd = (url in VaultAPICache)
        if (urlWaited && urlLoaded && !fnd)
        {
            dbgError ("======================================================");
            dbgError ("=== URL was loaded, but not in VaultAPICache [ASYNC Loading ERROR!, review addReqCache() in function submitVaultAPIRequest()]");
            dbgError ("=== URL: " + url);
            dbgError ("======================================================");
        }

        // structure of item { json: <json data>; timestamp: <last updated> }
        if (fnd)
        {
            if (!urlWaited && !urlLoaded)
            {
                // test if cache entry is old ...
                var millis = Date.now() - VaultAPICache[url]["timestamp"];
                if ((Math.floor(millis/1000)/60) > VaultCacheMaxAgeMinutes)
                {
                    // dbgInfo ("getReqCache: expired " + url);
                    delete VaultAPICache[url];
                    return [false, null];
                }
            }

            var data =  await Cryptoe.decrypt(VaultAPICache[url]["json"]);
            // if (url.match("^http.*"))
            //     dbgInfo ("getReqCache: data loaded " + url);
            return [true, data];
        }

        return [false, null];
    })();
}

async function addReqCache (url, data, vaultAPIPendingDict=null)
{
    var add2Cache = false;

    // dont store json data that is in error as this can lead to incorrect results
    if ((typeof data === "object") && !("errors" in data))
        add2Cache = true;
    else if ((data != null) && (data != ""))
        add2Cache = true;

    if (add2Cache)
    {
        new Promise(function(resolve, reject)
        {
            resolve(Cryptoe.encrypt(data));
        }).then (encyptedData => {
            VaultAPICache[url] = { "json":encyptedData, timestamp:Date.now() };

            // dbgInfo ("submitVaultAPIRequest: removing VaultAPIPending " + url);
            removeVaultAPIRequest(url, vaultAPIPendingDict);
        });
    }
}

var LastCacheStatus             = ""
function clrReqCache ()
{    
    if (VaultAPICache && (Object.keys(VaultAPICache).length > 0))
    {
        VaultAPICache = {};
        Cryptoe.init(16,64); // re-new the encryption key...
        
        if ((LastCacheStatus != "") && (LastCacheStatus != "cache-status-empty"))
        {
            dbgInfo ("clrReqCache: cache cleared! " + LastCacheStatus);
            LastCacheStatus = "";
            updateReqCacheIconStatus ();
        }
    }
}

// ################################################################################################

// matchFolderType bit values:
// 0  = match all data
// 1  = match non-leaf and leaf container folder
// 2  = match non-leaf container folder
async function vault_FetchQueryKVSecrets  (addr, token, version, name, path='', regMatch='', prnMatches=false, matchFolderType=0, notRegMatchPath='', recurse=true, ignoreVaultAbortSearch=false)
{
    return await (async () =>
    {
        // dbgTrace ("Reading: '" + name + path + "'")

        var cmpRegMatch        = new RegExp(regMatch, 'ig');
        var cmpNotRegMatchPath = new RegExp(notRegMatchPath, 'ig');
        var listURL            = addr;
        var rtnData            = { };

        // vault kv list <name>
        // list keys call
        if (version == '1')
            listURL = listURL + '/v1/' + gfURLEncode(name + path) + '?list=true'
        else if (version == '2')
            listURL = listURL + '/v1/' + gfURLEncode(name + 'metadata/' + path) + '?list=true';
        else
            return (null);

        // print (listURL)
        // dbgTrace ("Calling URL: " + listURL)
        var fldrDataOrig = null;

        if (vaultIsFolderPath(name+path))
        {
            var cache = await getReqCache (listURL);
            if (cache[0])
                fldrDataOrig = cache[1];
            else
            {
                submitVaultAPIRequest (token, listURL, true);
                cache = await getReqCache (listURL);
                if (cache[0])
                    fldrDataOrig = cache[1];
                else
                {
                    dbgError ("####### vault_FetchQueryKVSecrets : NULL Return 1! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls! " + listURL);
                    return null;
                }
            }
        }

        // vault kv get <name>/<key>
        var fldrDataKeys = { };

        if ((! fldrDataOrig) || ("errors" in fldrDataOrig))
        {
            dbgWarn ("vault_FetchQueryKVSecrets: list folder data is NULL! :  " + listURL);
            dbgWarn ("vault_FetchQueryKVSecrets: converting request to query KV item");

            if (path == '')
                return ([listURL, rtnData]);

            // convert failed list query to KV item query
            var p = gfRStrip(path, FLDRCHR);
            var k = p.split(FLDRCHR).pop();
            path = gfRStrip(p, k);
            fldrDataKeys = {0:  k};
        }
        else
        {
            //dbgTrace("== Dumping vault_FetchQueryKVSecrets '" + name + "/" + path + "' ==");
            //vaultDumpDict (fldrDataOrig);
            //dbgTrace("========================================");

            if ( ['1', '2'].includes(version))
                fldrDataKeys = fldrDataOrig['data']['keys'];
        }

        // Place url requests into pending load url list
        for (var i in fldrDataKeys)
        {
            var k = fldrDataKeys[i];

            // if using notRegMatchPath, then test if path matches, and continue/ignore
            if ((notRegMatchPath != '') && (k.match(cmpNotRegMatchPath)))
                 continue;

            if (k.match("\/$"))
                continue;

            var keyURL = '';
            if (version == '1')
            {
                keyURL = addr + '/v1/' + gfURLEncode(name + path + k);
                var cache = await getReqCache (keyURL);
                if (! cache[0])
                    submitVaultAPIRequest (token, keyURL, false);
            }
            else if (version == '2')
            {
                keyURL = addr + '/v1/' + gfURLEncode(name + 'data/' + path + k);
                var cache = await getReqCache (keyURL);
                if (! cache[0])
                    submitVaultAPIRequest (token, keyURL, false);
            }
        }

        // try and preload any folders recursively so they are in a pending state and  can be loaded concurrently...
        for (var i in fldrDataKeys)
        {
            if ((VaultAbortSearch) && (! ignoreVaultAbortSearch))
            {
                dbgError ("####### vault_FetchQueryKVSecrets : ABORTED 1! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls!");
                return null;
            }

            var k = fldrDataKeys[i];

            // if using notRegMatchPath, then test if path matches, and continue/ignore
            if ((notRegMatchPath != '') && (k.match(cmpNotRegMatchPath)))
                 continue;

            // if folder type, process this first and load pending requests...
            if (k.match("\/$") && recurse)
            {
                var ks = gfRStrip(k, FLDRCHR);
                var rtnVals = await vault_FetchQueryKVSecrets (addr, token, version, name, path + k, regMatch, prnMatches, matchFolderType, notRegMatchPath, recurse, ignoreVaultAbortSearch);
                if (rtnVals == null)
                {
                    dbgError ("####### vault_FetchQueryKVSecrets : NULL Return 2! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls! " + path + k);
                    return (null);
                }
                rtnData[k] = { apiURL: rtnVals[0],
                                scrtVersion: version,
                                scrtName: name,
                                scrtPath: path + k,
                                isLeafNode: false,
                                isEndFolder:false,
                                data: null,
                                child: rtnVals[1]
                              };
            }
        }

        // match and scran results from hopefully, now cached results.
        for (var i in fldrDataKeys)
        {
            if ((VaultAbortSearch) && (! ignoreVaultAbortSearch))
            {
                dbgError ("####### vault_FetchQueryKVSecrets : ABORTED 2! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls!");
                return null;
            }

            var k = fldrDataKeys[i];

            // if using notRegMatchPath, then test if path matches, and continue/ignore
            if ((notRegMatchPath != '') && (k.match(cmpNotRegMatchPath)))
                 continue;

            if (k.match("\/$") && recurse)
            {
               // already processed in previous loop
            }
            // matchFolderType:
            // 0  = match all data
            // 1  = match non-leaf and leaf container folder
            // 2  = match non-leaf container folder
            else if (matchFolderType < 2)
            {
                var keyURL = '';
                var leafData = null;
                if (version == '1')
                {
                    try
                    {                    
                        keyURL = addr + '/v1/' + gfURLEncode(name + path + k);
                        var leafNode = null;
                        var cache = await getReqCache (keyURL);
                        if (cache[0])
                            leafNode = cache[1];
                        else
                        {
                            dbgError ("####### vault_FetchQueryKVSecrets : NULL Return 3! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls! " + keyURL);
                            return (null);
                        }

                        if ((! leafNode) || ("errors" in leafNode))
                        {
                            dbgError ("vault_FetchQueryKVSecrets: leafNode(1) is NULL!");
                            continue; // return ([listURL, rtnData]);
                        }
                        leafData = leafNode['data']
                    }
                    catch (error)
                    {
                        dbgInfo ("MATCH ERROR matchFolderType[1]: " + error.message);
                        leafData = null;
                    }
                }
                else if (version == '2')
                {
                    try
                    { 
                        keyURL = addr + '/v1/' + gfURLEncode (name + 'data/' + path + k);
                        var leafNode = null;
                        var cache = await getReqCache (keyURL);
                        if (cache[0])
                            leafNode = cache[1];
                        else
                        {
                            dbgError ("####### vault_FetchQueryKVSecrets : NULL Return 4! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls! " + keyURL);
                            return (null);
                        }

                        if ((! leafNode) || ("errors" in leafNode))
                        {
                            dbgError ("vault_FetchQueryKVSecrets: leafNode(2) is NULL! '" + keyURL + "'");
                            continue; // return ([listURL, rtnData]);
                        }
                        leafData = leafNode['data']['data']
                    }
                    catch (error)
                    {
                        dbgInfo ("MATCH ERROR matchFolderType[2]: " + error.message);
                        leafData = null;
                    }
                }

                if (! leafData)
                {
                    dbgWarn ("vault_FetchQueryKVSecrets: leafData is NULL!");
                    // continue;
                }

                rtnData[k] = { child:{},
                               apiURL:keyURL,
                               scrtVersion: version,
                               scrtName: name,
                               scrtPath: path + k,
                               isLeafNode: false,
                               isEndFolder:true,
                               data:await Cryptoe.encrypt(leafData)
                             };
                var matched = false;

                try
                {
                    // if using regExpr matching, then load ALL of leaf node data
                    if ((regMatch != '') && (k.match(cmpRegMatch)))
                         matched = true;

                    // If matching against something ...
                    if ((regMatch != '') && (matched == false))
                    {
                        for (var lk in leafData)
                        {
                            if (typeof(leafData[lk]) == "object")
                                matched = ( lk.match(cmpRegMatch) || JSON.stringify(leafData[lk]).match(cmpRegMatch) ) ? true : false;
                            else
                                matched = ( lk.match(cmpRegMatch) || leafData[lk].match(cmpRegMatch) ) ? true : false;

                            if (matched)
                            {
                                if (prnMatches)
                                    dbgInfo ("vault_FetchQueryKVSecrets: Matched: " + name + path + k + ' :: ' + lk + ":" + leafData[lk]);
                                break;
                            }
                        }
                    }
                    else
                    {
                        matched = true;
                    }
                }
                catch (error)
                {
                    dbgInfo ("MATCH ERROR: " + error.message);
                    noteError ("Unhandled exception on matching with regular expression:<br>'" + regMatch + "'<br>" + error.message);
                    return null;
                }

                // matchFolderType:
                // 0  = match all data
                // 1  = match non-leaf and leaf container folder
                // 2  = match non-leaf container folder
                if (matchFolderType < 1)
                {
                    // If any match found, then add all of leaf data nodes to the list...
                    if (matched)
                    {
                        for (var lk in leafData)
                        {
                            // dbgTrace ("Storing: '" + name + path + k + '/' + lk + "'");
                            rtnData[k]["child"][lk] = { child:null,
                                                        apiURL:keyURL,
                                                        scrtVersion: version,
                                                        scrtName: name,
                                                        scrtPath: path + k,
                                                        isLeafNode: true,
                                                        isEndFolder:false,
                                                        data:await Cryptoe.encrypt(leafData[lk]),
                                                        id:gfCRC32(name + path + k, true) };
                        }
                    }
                }
            }

            let kobj = rtnData[k];
            // if using regExpr matching, and nothing is matched on this sub-key, then ignore its results
            if (kobj && (regMatch != '') && ((Object.keys(kobj["child"]).length <= 0) && (! k.match(cmpRegMatch))))
                delete rtnData[k];
        }

        return ([listURL, rtnData]);
   })();
}

// matchFolderType:
// 0  = match all data
// 1  = match non-leaf and leaf container folder
// 2  = match non-leaf container folder
async function vault_FetchQueryRootMounts (addr, token, name, path, regMatch='', matchFolderType=0, notRegMatchPath='',ignoreVaultAbortSearch=false)
{
    return await (async () =>
    {
        // Activate the search cache
        if (token != null)
            await addReqCache ("token", token);
        else
        {
            dbgError ("vault_FetchQueryRootMounts: token is NULL!");
            return null;
        }

        var cmpRegMatch = new RegExp(regMatch, 'ig');
        var listURL     = addr + '/v1/sys/internal/ui/mounts';
        var jsonData    = null;
        var cache       = await getReqCache (listURL);
        if (cache[0])
            jsonData = cache[1];
        else
        {
            submitVaultAPIRequest (token, listURL, true);
            cache = await getReqCache (listURL);
            if (cache[0])
                jsonData = cache[1];
            else
                return null;
        }

        if (! jsonData)
        {
            dbgError ("vault_FetchQueryRootMounts: jsonData is NULL!");
            return null;
        }

        // vaultDumpDict (jsonData);

        if ("errors" in jsonData)
        {
            clrReqCache();
            dbgError  ("vault_FetchQueryRootMounts: Failed query on " + listURL );
            dbgError  ("vault_FetchQueryRootMounts: " + jsonData["errors"]);
            noteError ("Failed Vault Request.<br>Please try re-authentication or check Vault service.<br>"+jsonData["errors"]);

            // can't continue these types of operations if it cannot event query root mounts!
            if (jsonData["errors"][0].match('denied'))
                 gfRefreshIFramePage ();

            return null;
        }

        // Make sure name has a trailing '/' for comparisons from json data
        if (name != '')
            name = gfRStrip(name, FLDRCHR) + FLDRCHR;

        var rtnData = { };
        var secrets=jsonData['data']['secret'];
        for (var key in secrets)
        {
            if ((VaultAbortSearch) && (! ignoreVaultAbortSearch))
            {
                dbgError ("####### vault_FetchQueryRootMounts : ABORTED! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls!");
                return null;
            }

            // dbgTrace (key + '::' + JSON.stringify(secrets[key]));
            // var rsKey = gfRStrip(key, FLDRCHR);

            // if name is not null, and does not  matches mount point key, continue
            if ((name != '') && (name != key))
                continue;

            if (secrets[key]['type'] == 'kv')
            {
                // Debugging log before calling the function
                dbgTrace(`Debug: Checking secrets[${key}] option version attribute exists`, secrets[key]);

                // Ensure secrets[key] exists
                if (!secrets[key]) 
                {
                    dbgWarn(`Error: secrets[${key}] is missing! Initializing empty object.`);
                    secrets[key] = {};
                }

                // Ensure options is always an object with a default version of '1'
                if (!secrets[key]['options']) 
                {
                    dbgWarn(`Warning: secrets[${key}]['options'] is NULL! Initializing with default version.`);
                    secrets[key]['options'] = { version: '1' };  // Default version set to '1'
                }

                // Use the version from options, defaulting to '1' if missing
                var rtnVals = await vault_FetchQueryKVSecrets (addr, token, secrets[key]['options']['version'] ?? '1', key, path, regMatch, false, matchFolderType, notRegMatchPath, true, ignoreVaultAbortSearch);

                if (rtnVals == null)
                {
                    dbgError ("####### vault_FetchQueryRootMounts : NULL Return 1! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls!");
                    return null;
                }
                rtnData[key] = { apiURL: rtnVals[0],
                                   scrtVersion: secrets[key]['options']['version'],
                                   scrtName: key,
                                   scrtPath: path,
                                   isLeafNode: false,
                                   isEndFolder:false,
                                   data: null,
                                   child: rtnVals[1]
                                 };
            }
            else if (secrets[key]['type'] == 'cubbyhole')
            {
                var rtnVals = await vault_FetchQueryKVSecrets (addr, token, '1', key, path, regMatch, false, matchFolderType, notRegMatchPath, true, ignoreVaultAbortSearch);
                if (rtnVals == null)
                {
                    dbgInfo ("####### vault_FetchQueryRootMounts : NULL Return 2! Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls!");
                    return null;
                }
                rtnData[key] = { apiURL: rtnVals[0],
                                   scrtVersion: '1',
                                   scrtName: key,
                                   scrtPath: path,
                                   isLeafNode: false,
                                   isEndFolder:false,
                                   data:null,
                                   child: rtnVals[1]
                                 };
            }
            else
                continue;

            // remove blank matches
            if ((regMatch != '') && ((Object.keys(rtnData[key]["child"]).length <= 0) && (! key.match(cmpRegMatch))))
                delete rtnData[key];
        }

        dbgTrace ("####### vault_FetchQueryRootMounts : Exiting Loaded " + Object.keys(VaultAPICache).length +  ", pending " + Object.keys(VaultAPIPending).length + " urls!");
        return rtnData;
   })();
}

// ======================================= End of vaultbulkloader Insert =========================================

var AsyncCacheLoading           = false;
var AsyncCacheLastLoadedTime    = Date.now();
var AsyncCacheRefreshLoadedTime = Date.now();

function updateReqCacheIconStatusNow ()
{
    var statusChng = ""
    if (AsyncCacheLoading)
        statusChng = "cache-status-loading";
    else
        statusChng = "cache-status-full";
    if (LastCacheStatus != statusChng)
    {
        $("#cache-status-icon").removeClass("cache-status-loading cache-status-full cache-status-empty");
        $("#cache-status-icon").addClass(statusChng);
        LastCacheStatus = statusChng;
    }
}

function updateReqCacheIconStatus ()
{
    (async () =>
    {
        var statusChng = ""
        var chkToken = await getReqCache ("token");
        if (chkToken[0] && (chkToken[1] != null))
            if (AsyncCacheLoading)
                statusChng = "cache-status-loading";
            else
                statusChng = "cache-status-full";
        else
            statusChng = "cache-status-empty";
        if (LastCacheStatus != statusChng)
        {
            $("#cache-status-icon").removeClass("cache-status-loading cache-status-full cache-status-empty");
            $("#cache-status-icon").addClass(statusChng);
            LastCacheStatus = statusChng;
        }
    })();
}

// check if token differs from cache, if so then clear cache, and if not null, add it to the cache
function chkReqCache (token)
{
    (async () =>
    {
        var chkToken = await getReqCache ("token");
        if ((token == null) || (chkToken[0] && (chkToken[1] != token)))
        {
            clrReqCache();
        }
    })();
}

async function LoadBulkData (bulkData)
{
    if (bulkData)
    {
        // check if request is coming from a proxy host. 
        // update the returned key data to this req's proxy host
        // replace https://vault.server.com/ to https://vault-proxy.server.com/
        const getRtnHost = /^(http|https)(\:\/\/)(.*?)(\/.*)/gm;
                            
        // load and encrypt the data from bulk loader process
        for (var key in bulkData) 
        {
             let m = getRtnHost.exec(key);                         

            // check key/url matches this hosts server, otherwise change it to match reverse proxy
            if (m && (m[3] != location.host))
            {
                // update source host name to proxy host name (i.e this web site's url)
                let newKey = key.replace(getRtnHost, "$1$2" + location.host +"$4");                                
                addReqCache (newKey, bulkData[key].json);
            }
            else                        
                addReqCache (key, bulkData[key].json);
        }
    }
}

var ShowSearchTools   = false;
var URLGotoActionTest = true;
function AsyncCacheLoad ()
{    
    // check if token is current...
    var token = vaultToken();
    if (token == null)
    {
        if (ShowSearchTools)
        {
            // $(".ShowSearchTools").css("display", "none");
            $(".ShowSearchTools").hide(800, "swing");
            ShowSearchTools = false;
        }
    }
    else if (!ShowSearchTools)
    {
        // $(".ShowSearchTools").css("display", "block");
        $(".ShowSearchTools").show(800, "swing");
        $("#vault_search").next().find('input').focus();
        ShowSearchTools = true;
         
        // parse url search parameters, and jump to page upon first load/login into Vault
        if (URLGotoActionTest)        
        {
            URLGotoActionTest = false;            
            let vp = gfGetParameterByName("goto");
            if (vp)
            {
                vaultUIGotoPath (unescape(vp));
            }
        }

        // Wait for #search-tools-width to be fully rendered to get its actual width as this can vary significantly while a page is loading!
        setTimeout(function() {
            // set the min width for the tool bar to prevent possible flickering when doing a search action.    
            dbgInfo ("AsyncCacheLoad() iframe #search-tools-width.outerWidth() : " +  $('#search-tools-width').outerWidth());
            dbgInfo ("AsyncCacheLoad() iframe scrollbar : " + ($.position.scrollbarWidth()) );
            dbgInfo ("AsyncCacheLoad() set iframe #search-tools-width.outerWidth() + scrollbar  : " + ($('#search-tools-width').outerWidth()+$.position.scrollbarWidth()) );
            $('#iframe_table').css('min-width', ($('#search-tools-width').outerWidth()+$.position.scrollbarWidth()) + 'px');
        }, 1000);
    }

    // If not enabled, and loading already ... exit
    if ((! AsyncCacheEnabled) || (AsyncCacheLoading))
        return;

    (async () =>
    {
        // check if token in cache is the same!
        await chkReqCache (token);
        var chkToken = (await getReqCache ("token"))[1];
        if (token != "" && token != null)
        {
            var diffLastFullCacheLoadMillis = Date.now();
            if (AsyncCacheLastLoadedTime != null)
                diffLastFullCacheLoadMillis -= AsyncCacheLastLoadedTime;

            var diffLastRefreshCacheLoadMillis = Date.now();
            if (AsyncCacheRefreshLoadedTime != null)
                diffLastRefreshCacheLoadMillis -= AsyncCacheRefreshLoadedTime;

            if ((chkToken != token) || ((Math.floor(diffLastFullCacheLoadMillis/1000)/60) > VaultCacheMaxAgeMinutes))
            {
                // Try load using the bulk loader method if its active.
                let startTimeStamp = new Date();                
                AsyncCacheLoading = true;      
                updateReqCacheIconStatusNow ();
                
                dbgInfo ("AsyncCacheLoad: async vaultbulkcacheloader cache loading ... ");              
                let bulkData = await fetch(VaultAddr + '/vaultbulkcacheloader?proxyhost=' + location.host, {
                                        method: 'GET',
                                        headers: { "x-vault-token" : token },
                                        cache: 'no-cache'
                                    })
                                    .then((response) => response.json())
                                    .then(data => {                                         
                                        if (data && !(data.hasOwnProperty("errors")))
                                            dbgInfo('AsyncCacheLoad: vaultbulkcacheloader Success:');
                                        else
                                        {
                                            dbgInfo('AsyncCacheLoad: vaultbulkcacheloader Failure!');
                                            return null;
                                        }
                                        return data;
                                    })
                                    .catch((error) => {
                                            dbgError  ("AsyncCacheLoad: vaultbulkcacheloader: Error failed request on vaultbulkcacheloader ");
                                            dbgError  ("AsyncCacheLoad: vaultbulkcacheloader: " + error);
                                            return null;
                                    });
                if (bulkData)
                {                                        
                    LoadBulkData (bulkData);
                  
                    let endTimeStamp   = new Date();
                    let elapsedSeconds = (endTimeStamp.getTime() - startTimeStamp.getTime()) / 1000;
                    dbgInfo ("AsyncCacheLoad: vaultbulkcacheloader call returned, cache loaded in " + elapsedSeconds + " seconds loaded " + Object.keys(bulkData).length +  " urls!");
                }
                else // failover to older method
                {
                    dbgInfo ("AsyncCacheLoad: async fallback cache loading ... ");
                    
                    await addReqCache ("token", token);
                    await vault_FetchQueryRootMounts (VaultAddr, token, '', '', '', 0, (SearchRecycleBinEnabled ? '' : VaultRecycleBinPath + '\/'), true);

                    let endTimeStamp = new Date();
                    let elapsedSeconds = (endTimeStamp.getTime() - startTimeStamp.getTime()) / 1000;
                    dbgInfo ("AsyncCacheLoad: vault_QueryRootMounts call returned, cache loaded in " + elapsedSeconds + " seconds loaded " + Object.keys(VaultAPICache).length +  " urls!");
                }
                AsyncCacheLoading           = false;
                AsyncCacheLastLoadedTime    = Date.now();
                AsyncCacheRefreshLoadedTime = Date.now();                
                updateReqCacheIconStatusNow ();
            }
            else if ( ((Math.floor(diffLastRefreshCacheLoadMillis/1000)/60) > VaultCacheRefreshMinutes))
            {            
                // Try load using the bulk loader method if its active.
                let startTimeStamp = new Date();
                AsyncCacheLoading = true;
                updateReqCacheIconStatusNow ();
        
                dbgInfo ("AsyncCacheLoad: async vaultbulkcacheloader cache refresh ... ");
                let bulkData = await fetch(VaultAddr + '/vaultbulkcacheloader?proxyhost=' + location.host + '&token=' + token, {
                                        method: 'GET',
                                        headers: { "x-vault-token" : token },
                                        cache: 'no-cache'
                                    })
                                    .then(response => response.json())
                                    .then(data => {
                                         dbgInfo('AsyncCacheLoad: vaultbulkcacheloader Success:');
                                         return data;
                                    })
                                    .catch((error) => {
                                            dbgError  ("AsyncCacheLoad: vaultbulkcacheloader: Error failed request on vaultbulkcacheloader ");
                                            dbgError  ("AsyncCacheLoad: vaultbulkcacheloader: " + error);
                                            return null;
                                    });                
                if (bulkData)
                {                                   
                    LoadBulkData (bulkData);
                    
                    let endTimeStamp   = new Date();
                    let elapsedSeconds = (endTimeStamp.getTime() - startTimeStamp.getTime()) / 1000;
                    dbgInfo ("AsyncCacheLoad: vaultbulkcacheloader call returned, cache refreshed in " + elapsedSeconds + " seconds loaded " + Object.keys(bulkData).length +  " urls!");
                }
                else // failover to older method
                {                
                    let counter        = 0;
                    var vaultAPIRefreshPending = { }; // use a different pending promise list than the default so as not to block any current search requests
                    dbgInfo ("AsyncCacheLoad: async cache refreshing ... ");
                    AsyncCacheLoading = true;
                    for (let [url, uobj] of Object.entries(VaultAPICache))
                    {
                        if (! url.match("^http.*"))
                            continue;

                        submitVaultAPIRequest (token, url, false, vaultAPIRefreshPending);

                        // every 100 urls processed, wait for the last one, until they are loaded before continuing so as try and not bog down the browser page...
                        counter++;
                        if ((counter % 100) == 0)
                        {
                            const interrupt = 1;
                            const timeOut   = (1000/interrupt)*30;
                            for (var i = 0; i < timeOut; i++)
                            {
                                let uobj = vaultAPIRefreshPending[url]; // if object not in pending download list, then exit loop and continue to download ...
                                if (! uobj)
                                    break;

                                // if attached promise, then block/wait until its completed...
                                if (uobj.promise)
                                    await uobj.promise;

                                // release cpu in this thread of execution to allow item to be removed from VaultAPIPending, and placed into VaultAPICache
                                await new Promise(s => setTimeout(s, interrupt));
                            }
                        }
                    }
                    
                    let endTimeStamp = new Date();
                    let elapsedSeconds = (endTimeStamp.getTime() - startTimeStamp.getTime()) / 1000;
                    dbgInfo ("AsyncCacheLoad: completed cache refresh in " + elapsedSeconds + " seconds loaded " + Object.keys(VaultAPICache).length +  ", urls!");                    
                }

                AsyncCacheLoading           = false;
                AsyncCacheRefreshLoadedTime = Date.now();
                updateReqCacheIconStatusNow ();
            }
        }
    })();
}

const AsyncCookieName = "SEARCHREC-ASYNC-BUTTON"

function AsyncCacheButtonEvent (switchState=true)
{
    if (switchState)
        AsyncCacheEnabled = ! AsyncCacheEnabled;

    dbgInfo ("AsyncCacheButtonEvent: Async load " + AsyncCacheEnabled);
    // Update button state
    if (AsyncCacheEnabled)
    {
        $("#cache-async-icon").css("color", "#00C800");
        $("#cache-async-icon").attr("title", "Asynchronous Vault secrets cache loading is ENABLED");
        clrReqCache();
        AsyncCacheLoad ();
    }
    else
    {
        $("#cache-async-icon").attr("title", "Asynchronous Vault secrets cache loading is DISABLED");
        $("#cache-async-icon").css("color", "red");
    }

    gfSetCookie (AsyncCookieName, AsyncCacheEnabled, 365);
}

function AsyncCacheSetButton ()
{
    var c = gfGetCookie (AsyncCookieName);
    try
    {
        AsyncCacheEnabled = eval(c);
        if (AsyncCacheEnabled === undefined)
            AsyncCacheEnabled = true;
    }
    catch
    {
        AsyncCacheEnabled = true;
    }

    AsyncCacheButtonEvent (false);
}


const SearchRecycleBinName = "SEARCH-RECYCLE-BIN-BUTTON"

function SearchRecyleBinButtonEvent (switchState=true)
{
    if (switchState)
        SearchRecycleBinEnabled  = ! SearchRecycleBinEnabled ;

    dbgInfo ("SearchRecyleBinButtonEvent: : " + VaultRecycleBinPath + " search " + SearchRecycleBinEnabled);

    // Update button state
    if (SearchRecycleBinEnabled )
    {
        $("#search-recyclebin-icon").css("color", "darkgreen");
        $("#search-recyclebin-icon").attr("title", "Searching " + VaultRecycleBinPath + " folders is ENABLED");
    }
    else
    {
        $("#search-recyclebin-icon").attr("title", "Searching " + VaultRecycleBinPath + " folders is DISABLED");
        $("#search-recyclebin-icon").css("color", "red");
    }

    gfSetCookie (SearchRecycleBinName, SearchRecycleBinEnabled, 365);
}

function SearchRecycleBinSetButton ()
{
    var c = gfGetCookie (SearchRecycleBinName);
    try
    {
        SearchRecycleBinEnabled = eval(c);
        if (SearchRecycleBinEnabled === undefined)
            SearchRecycleBinEnabled = false;
    }
    catch
    {
        SearchRecycleBinEnabled = false;
    }

    SearchRecyleBinButtonEvent (false);
}

var ThisSrchResultsDialogBox = null;

function delSearchDialog ()
{
    try
    {
        // clear node data
        $('#searchOutput').jstree(true).settings.core.data = {};
        $('#searchOutput').jstree(true).refresh();
        $('#searchOutput').jstree(true).show_all();
        $('#searchOutput').jstree("open_all");
    } catch(err) {}
    try { ThisSrchResultsDialogBox.dialog("close"); } catch(err) { }
    ThisSrchResultsDialogBox = null;
}

var MaxRecentSearchs = 10;
var RecentSearchText = [];
var PinnedSearchText = [];
function SearchComboBoxSaveCookieSettings ()
{
    gfSetCookie ("cb-recentSearch",  String(JSON.stringify(RecentSearchText)), 365);
    gfSetCookie ("cb-pinnedSearch",  String(JSON.stringify(PinnedSearchText)), 365);
}

function SearchComboBoxLoadCookieSettings ()
{
    try
    {
        $("#vault_search").children().remove();
        RecentSearchText = eval(gfGetCookie ("cb-recentSearch"));
        if (RecentSearchText == undefined)
            RecentSearchText = [];

        PinnedSearchText = eval(gfGetCookie ("cb-pinnedSearch"));
        if (PinnedSearchText == undefined)
            PinnedSearchText = [];
    }
    catch
    {
        RecentSearchText = [];
        PinnedSearchText = [];
    }

    renderSearchComboBox ();
}

function renderSearchComboBox ()
{
    $("#vault_search").children().remove();

    for (var idx = 0; idx < RecentSearchText.length; idx++)
    {
        if (RecentSearchText[idx].startsWith("<option"))
            RecentSearchText[idx] = $(RecentSearchText[idx]).map(function() { return $(this).val(); })[0]

        var label = RecentSearchText[idx];
        var cust  = '<span style="float:right"><a href="#" style="color:red" onclick="event.stopPropagation();removeSearchComboBoxItem (' + "'RecentSearchText'," + idx + ');"><i class="far fa-times-circle"></i></a></span>';
        var op    = $("<option>");
        op.text(label);
        op.attr("cust_html", btoa(cust));
        $("#vault_search").append(op);
        // $("#vault_search").append("<option value=' '>" + RecentSearchText[idx] + "</option>");
    }

    if (PinnedSearchText.length > 0)
    {
        // This works as a separator
        $("#vault_search").append('<option value="-">-</option>');

        for (var idx = 0; idx < PinnedSearchText.length; idx++)
        {
            var label = PinnedSearchText[idx];
            var cust  = '<span style="float:right"><a href="#" style="color:red" onclick="event.stopPropagation();removeSearchComboBoxItem (' + "'PinnedSearchText'," + idx + ');"><i class="fa fa-map-pin"></i></a></span>';
            var op    = $("<option>");
            op.text(label);
            op.attr("cust_html", btoa(cust));
            $("#vault_search").append(op);
        }
    }
}

function pinStatusSearchComboBox (testStr)
{
    if (testStr == null || testStr.trim() == "")
    {
        $("#pin-search-txt-icon").css("color", "");
        return;
    }

    testStr = testStr.trim();

    // dbgInfo ("pinStatusSearchComboBox: " + testStr);

    // If value already exists, then show red pin
    for (var idx=0; idx < PinnedSearchText.length; idx++)
    {
        if (PinnedSearchText[idx].toLowerCase()  == testStr.toLowerCase())
        {
            $("#pin-search-txt-icon").css("color", "red");
            return;
        }
    }
    $("#pin-search-txt-icon").css("color", "darkgreen");
}

function pinAddRemoveSearchComboBox (testStr)
{
    if (testStr == null || testStr.trim() == "")
        return;
    testStr = testStr.trim();

    dbgInfo ("pinAddRemoveSearchComboBox: " + testStr);
    var newPin = [];
    var fndPin = false;
    for (var idx=0; idx < PinnedSearchText.length; idx++)
    {
        if (PinnedSearchText[idx].toLowerCase() != testStr.toLowerCase())
            newPin.push(PinnedSearchText[idx]);
        else
        {
            noteNorm ("Unpinned: " + testStr);
            fndPin = true;
        }
    }

    if (! fndPin)
    {
        noteNorm ("Pinned: " + testStr);
        newPin.unshift(testStr);
    }

    PinnedSearchText = newPin;
    renderSearchComboBox ();
    pinStatusSearchComboBox (testStr);
    SearchComboBoxSaveCookieSettings ();
}

function removeSearchComboBoxItem (listType, labelIdx)
{
    listType = listType.toLowerCase();
    if (listType == 'RecentSearchText'.toLowerCase())
    {
        var updateRecents = [];
        var testStr    = "";
        for (var idx=0; idx < RecentSearchText.length; idx++)
        {
            if (idx == labelIdx)
            {
                testStr = RecentSearchText[idx];
                noteNorm ("Removed: " + testStr);
            }
            else
                updateRecents.push(RecentSearchText[idx]);
        }        
        RecentSearchText = updateRecents;
    }
    else if (listType == 'PinnedSearchText'.toLowerCase())
    {
        var updatePins = [];
        var testStr    = "";
        for (var idx=0; idx < PinnedSearchText.length; idx++)
        {
            if (idx == labelIdx)
            {
                testStr = PinnedSearchText[idx];
                noteNorm ("Unpinned: " + testStr);
            }
            else
                updatePins.push(PinnedSearchText[idx]);
        }

        PinnedSearchText = updatePins;
    }
    
    renderSearchComboBox();
    pinStatusSearchComboBox (testStr);
    SearchComboBoxSaveCookieSettings ();
    $('#vault_search').next().find('input').autocomplete ("search","")
}

function updateSearchComboBox (addStr)
{
    if (addStr == null || addStr.trim() == "")
        return;

    // If value already exists, then ignore...
    for (var idx=0; idx < RecentSearchText.length; idx++)
        if (RecentSearchText[idx].toLowerCase()  == addStr.toLowerCase())
            return;

    for (var idx=0; idx < PinnedSearchText.length; idx++)
        if (PinnedSearchText[idx].toLowerCase()  == addStr.toLowerCase())
            return;

    // prune least recently used
    if (RecentSearchText.length >= MaxRecentSearchs)
        RecentSearchText   = RecentSearchText.slice(0, RecentSearchText.length-1);

    RecentSearchText.unshift(addStr);

    renderSearchComboBox ();
    SearchComboBoxSaveCookieSettings ();
}

function cutCopyDelActionCheckBoxSearch (oper)
{
    var treeInst = $('#searchOutput').jstree(true);

    var operPaths = [];

    $.each($('#searchOutput').jstree("get_checked",null,true), function ()
    {
        var node = treeInst.get_node(this);

        if (typeof node.data.scrtName == "undefined")
            return; // igore this data structure.

        var path = node.data.scrtName + node.data.scrtPath;
        if (path.endsWith(FLDRCHR))
        {
            for (var i = 0; i < operPaths.length; i++)
            {
                if (operPaths[i].startsWith(path))
                    return; // ignore this path as its already included as part of the child items
            }
        }
        else
            operPaths.push (path);
        dbgTrace ("Checked item : " + node.id + ' : ' + path);
        //dbgInfo ("Checked item : " + node.id + " : " + JSON.stringify(node.data,  null, 4));
    });

    if (operPaths.length > 0)
    {
        var paths = ""
        for (var i = 0; i < operPaths.length; i++)
            paths += operPaths[i] + '\n';

        switch (oper)
        {
            case "cut-chkbox":
            case "copy-chkbox":
                cutCopyAction (oper, paths, '#search-chkboxs-controls');
                break;

            case "del-chkbox":
                nodeDeleteItem (null, paths, "chkbox");
                break;

        }
    }
}

function onOffActionCheckBoxSearch ()
{
    if ($('#search-onoff-chkboxs.fa-toggle-off').length)
    {
        $('#search-chkboxs-controls').css('display', 'block');
        $('#search-onoff-chkboxs').addClass('fa-toggle-on').removeClass('fa-toggle-off');
        $('#searchOutput').jstree(true).show_checkboxes();
    }
    else
    {
        $('#search-chkboxs-controls').css('display', 'none');
        $('#search-onoff-chkboxs').addClass('fa-toggle-off').removeClass('fa-toggle-on');
        $('#searchOutput').jstree(true).hide_checkboxes();
    }

}

// Run recursive search, if param secretNamePath is null/blank, then use current vault folder location to start search
function runSearch (secretNamePath = null)
{
    var baseName = "";
    var basePath = "";
    if (secretNamePath && (secretNamePath != ''))
    {
        if (secretNamePath != FLDRCHR) // use '/' to reference from root path
        {
            baseName = secretNamePath.split(FLDRCHR)[0] + FLDRCHR;
            basePath = secretNamePath.split(FLDRCHR).slice(1).join(FLDRCHR);
        }
    }
    else
    {
        var rtnVals  = vault_pathURLtoNamePath (VaultCurrentURL);
        baseName = unescape(rtnVals[0]);
        basePath = unescape(rtnVals[1]);
    }

    //var srchTxt = $('#vault_search').val();
    var srchTxt = gfTrim($('#vault_search').next().find('input').val(), ' ');

    // prevent this issue "test_mount_point/" "/test space/", needs to "test_mount_point/" "test space/"
    if ((basePath != '' && basePath[0] == FLDRCHR) && (baseName != '' && baseName[baseName.length-1] == FLDRCHR))
    {
        basePath = gfLStrip (basePath, FLDRCHR);
    }
       
    dbgInfo ("runSearch: BaseName  : " + baseName);
    dbgInfo ("runSearch: BasePath  : " + basePath);
    dbgInfo ("runSearch: RegExp    : " + srchTxt);

    // Test srchTxt txt
    try
    {
        "".match(srchTxt);
    }
    catch (err)
    {
        noteError("Not a valid Search String/Regular Expression!<br>" + srchTxt);
        return;
    }

    // Retrieve the token for the session with vault Ember magic code
    var ifr = document.getElementById(FrameID);
    var token = vaultToken();
    dbgTrace ("token = " + token);

    if (token == null)
    {
        noteError ("Please Login before search can be used.");
        return false;
    }

    delSearchDialog ();

    setTimeout(function()
    {
        // Implement async based fetch() ajax calls:
        //     create a callback async function to handle block await syntax
        (async () =>
        {
            chkReqCache (token);

            if (srchTxt == '')
            {
                setTimeout (function() {
                    if (! VaultAbortSearch)
                        noteNorm ("Search is blank!<br>Note this may take sometime to render full list!");
                }, 4000);
            }

            updateSearchComboBox (srchTxt);

            // Show pacifier to user show work in progress...
            vaultActionStartEnd ();

            var rtnData = await vault_FetchQueryRootMounts (VaultAddr, token, baseName, basePath, srchTxt, 0, (SearchRecycleBinEnabled ? '' : VaultRecycleBinPath + '\/'));

            updateReqCacheIconStatus ();
            dbgInfo ("runSearch: Search results returned");
            if ((rtnData != null) && (Object.keys(rtnData).length > 0))
            {
                //DebugMode  = DebugTrace;
                //vaultDumpDict (rtnData);
                dbgInfo ("runSearch: Converting search results");
                if (basePath != "")
                {
                    var newRtnData = {};
                    newRtnData[baseName + basePath] = rtnData[Object.keys(rtnData)[0]];
                    rtnData = newRtnData;
                }
                var treeData = await vault_jsTreeSearchDict (rtnData);

                //vaultDumpDict (treeData);
                //DebugMode  = DebugInfo;
                dbgInfo ("runSearch: Rendering search results via jstree()");

                $('#searchOutput').jstree('destroy');
                $('#searchOutput').jstree({
                    "core" : {
                        "animation" : 1,
                        "check_callback" : true,
                        "dots": true,
                        "icons": true,
                        "themes" : { "stripes" : true }
                    },
                    "types" : {
                        "leaf-node" : { "icon" : "blank" }
                    },
                    'themes' : {
                        'responsive' : false,
                        'variant' : 'small',
                        'stripes' : true
                    },

                    "checkbox" : {
                        "keep_selected_style" : false,
                        "whole_node":false,
                        "tie_selection":false,
                        'visible' :  $('#search-onoff-chkboxs').hasClass('fa-toggle-on')
                    },

                    "search" : {
                        'show_only_matches' : true,
                        'show_only_matches_children' : true
                    },

                    "plugins" : [
                        "state", "types",  "search", "checkbox"
                    ]
                });

                // implement sub-search
                $('#subSearchOutput').val('');
                var to = false;
                $('#subSearchOutput').keyup(function ()
                {
                    if(to) { clearTimeout(to); }
                    to = setTimeout(function ()
                    {
                        var v = $('#subSearchOutput').val();
                        $('#searchOutput').jstree(true).search(v);
                    }, 1000);
                });

                $('#searchOutput').jstree(true).settings.core.data = treeData;
                $('#searchOutput').jstree(true).refresh();
                $('#searchOutput').jstree(true).show_all();
                $('#searchOutput').jstree("open_all");

                var h             = (window.innerHeight / 100) * 90;
                var w             = (window.innerWidth  / 100) * 90;
                var toolBarHeight = $('#iframe_table table tr').eq(0).height();
                ThisSrchResultsDialogBox = $("#searchDialog").dialog({
                                            width:     'auto',                                             
                                            height:     h,
                                            autoOpen:  false,
                                            modal:     false,
                                            show:      'fold',
                                            hide:      'fold',
                                            show: {effect: 'fade', duration: 50},
                                            hide: {effect: 'fade', duration: 50},
                                            position: {of:       window,
                                                       my:       'left top',                                                       
                                                       at:       'left+3 top+' + (toolBarHeight+8),
                                                       collision:'none'
                                                      },

                                            // Store search data in dialog as an attribute
                                            output_vault: rtnData,
                                            output_jstree: treeData,
                                        });

                // hack to insert icons
                ThisSrchResultsDialogBox.data( "uiDialog" )._title = function(title)
                                                                     {
                                                                         title.html( this.options.title );
                                                                     };

                // Add minwidth option here is it is not registered in the main Dialog create call.
                ThisSrchResultsDialogBox.dialog('option', 'minWidth', 350);

                var expJSONCall = "vault_dumpSearchTreeToJSON(ThisSrchResultsDialogBox.dialog('option', 'output_vault'))"
                var icon = '<button onclick="' + expJSONCall + '; return false;"  type="button" class="ui-button ui-corner-all ui-widget ui-button-icon-only custom-title-button" title="Export output to JSON">' +
                           '<span class="ui-icon ui-icon-disk"></span><span class="ui-button-icon-space"> </span>Export output to JSON</button>';

                // insert icon and title text
                ThisSrchResultsDialogBox.dialog('option', 'title', icon + ' Regexp Search Results: ' + baseName + basePath + srchTxt);

                $("#searchDialog").prev(".ui-dialog-titlebar").css("background-color","darkblue");
                $("#searchDialog").prev(".ui-dialog-titlebar").css("color","white");

                ThisSrchResultsDialogBox.dialog('open');
            }
            else if ((rtnData != null) && (Object.keys(rtnData).length <= 0))
            {
                var p = baseName + basePath;
                var baseErr = '<p style="text-align:left;white-space:nowrap;margin:0px">Failed to match: <b style="font-size:large">' + srchTxt + '</b></p>';
                if (p != "")
                {                         
                    baseErr =  baseErr +
                              '<p style="text-align:left;white-space:nowrap;margin:0px">From path: <b style="font-size:large">' + p + "</b></p>" +
                              "<p style='background-color: inherit; float:left; position: absolute; top:-13px; left:-32px;'>" + 
                                  "<a id='searchrun-but' href='#' onclick='$(\"#userNoteErr\").fadeOut(500);runSearch(\"/\");' title='Search in -All Secrets-'>" + 
                                  "<span class='fa-stack hover-white'>" +
                                      "<i class='fa fa-search fa-stack-1x' style='font-size:large;color:#5cb3de'></i>" +
                                      "<i class='fa fa-search'             style='position: relative; left:-3px; top:4px;font-size:large'></i>" +                                 
                                  "</span>" +     
                                  "</a>"+
                              "</p>";
                }
                
                noteError (baseErr);
            }
            else if (VaultAbortSearch)
            {
                dbgInfo ("runSearch: vault_QueryRootMounts call returned, VaultAbortSearch");
            }
            else
            {
                dbgError ("runSearch: vault_QueryRootMounts returned DATA IS NULL!");
            }

            // Hide pacifier
            vaultActionStartEnd (true);
        })();
    }, 100);

    return false;
}

function reshowResultsDialog ()
{
    (async () =>
    {
        if (ThisSrchResultsDialogBox)
        {
            var token = vaultToken();
            if (token == null)
            {
                delSearchDialog ();
                noteError ("Cache was cleared. Please run another search");
            }
            else
            {
                ThisSrchResultsDialogBox.dialog("open");
            }
        }
        else
            noteNorm ("Please run a search first before using this action");
    })();
}

async function vault_DeleteNode (addr, token, version, name, path)
{
    // delete operation
    return await (async () =>
    {
        dbgInfo ("vault_DeleteNode: '" + name + path + "'")

        var delURL = addr;

        if (version == '1')
            delURL = delURL + '/v1/' + gfURLEncode(name + path);
        else if (version == '2')
            delURL = delURL + '/v1/' + gfURLEncode(name + 'metadata/' + path);

        var d = await fetch(delURL, {
                method: 'DELETE',
                headers: { "x-vault-token" : token },
                cache: 'no-cache'
            })
            .then(data => {
                 dbgInfo('vault_DeleteNode: Success:' + name + path);
                 clrReqCache();
                 return data;
            })
            .catch((error) => {
                    dbgError  ("vault_DeleteNode: Error failed request on " + delURL);
                    dbgError  ("vault_DeleteNode: " + error);
                    clrReqCache();
                    noteError ("Failed Vault Delete for: " + name  + path);
                    return null;
        });

        return d;
    })();
}

// Recursive delete child vault items
function nodeDeleteDict (addr, token, vaultDictList, jqOutput)
{
    for (var k in vaultDictList)
    {
        if (vaultDictList[k]["child"] )
        {
            nodeDeleteDict (addr, token, vaultDictList[k]["child"], jqOutput)
        }

        if (vaultDictList[k].isLeafNode == false)
        {
            dbgInfo ("nodeDeleteDict : Delete Node V:" + vaultDictList[k].scrtVersion + " N:" + vaultDictList[k].scrtName + " P:" + vaultDictList[k].scrtPath);
            if (jqOutput)
            {
                $(jqOutput).append("<p>Deleting Node:" + vaultDictList[k].scrtName + vaultDictList[k].scrtPath + "</p>");
            }
            vault_DeleteNode (addr, token, vaultDictList[k].scrtVersion, vaultDictList[k].scrtName, vaultDictList[k].scrtPath);
        }
    }
}

function nodeDeleteCountDict (vaultDictList)
{
    var c = 0;
    for (var k in vaultDictList)
    {
        if (vaultDictList[k]["child"] )
        {
            c += nodeDeleteCountDict (vaultDictList[k]["child"]);
        }

        c++;
    }
    return c;
}

// operType : Setting this will remove tree items from ThisSrchResultsDialogBox, if its present.
//            'single' for single selected row in ThisSrchResultsDialogBox
//            'chkbox' for check box items that match paths in ThisSrchResultsDialogBox
function nodeDeleteItem (element, paths, operType="")
{
    var token = vaultToken();
    dbgTrace ("token = " + token);

    if (token == null)
    {
        noteError ("Please Login before deletion can be used.");
        return false;
    }

    var saveCSS = "";
    if (element)
    {
        saveCSS = $(element).attr("class");
        $(element).removeClass("fa-trash-alt");
        $(element).addClass("fa-cog");
        $(element).addClass("fa-spin");
    }

    setTimeout(function()
    {
        (async () =>
        {
            // Show pacifier to user show work in progress...
            vaultActionStartEnd ();

            var deleteItems = { };

            // loop through deletion paths list ...
            var pathList      = unescape(paths).split("\n");
            var pathParamList = {};
            for (var idx = 0; idx < pathList.length; idx++)
            {
                // Cleans the pathing and spaces
                var path = gfRStrip(gfLStrip(pathList[idx], ' '), ' ');

                if (path == "")
                    continue;

                var list       = path.split(FLDRCHR);
                var secretName = list[0] + FLDRCHR;
                var secretPath = gfLStrip(list.splice(1).join(FLDRCHR), FLDRCHR);

                // Determine source version and destination version!
                var secretVer = await vault_SecretsVersion (VaultAddr, token, secretName);

                dbgInfo ("nodeDeleteItem : ver=" + secretVer + " name=" + secretName + " path=" + secretPath);

                VaultAbortSearch = false;
                var rtnVals = await vault_FetchQueryKVSecrets (VaultAddr, token, secretVer, secretName, secretPath);
                if (rtnVals == null)
                {
                    dbgError ("nodeDeleteItem : vault_FetchQueryKVSecrets something went wrong!");
                    return false;
                }

                if (VaultAbortSearch)
                    return false;

                var childItems = rtnVals[1];

                // store these details for later actual delete action...
                pathParamList[path] = {scrtVersion: secretVer, scrtName:secretName,  scrtPath:secretPath, delItems:childItems};
                
                let isLeafNode  = false;
                let isEndFolder = false;
                
                // if no children items, then this item much be a leaf item ... 
                if (Object.keys(childItems).length <= 0)
                {
                    isLeafNode = isEndFolder = true;                    
                }
                
                // Add this call as the parent into the dict list
                deleteItems[secretName+secretPath] = { apiURL: 'NOT USED',
                                                                scrtVersion: secretVer,
                                                                scrtName:    secretName,
                                                                scrtPath:    secretPath,
                                                                isLeafNode:  isLeafNode,
                                                                isEndFolder: isEndFolder,
                                                                data:        null,
                                                                child:       childItems
                                                     };
            }
            var treeData = vault_jsTreeAllDict (deleteItems);

            $('#deleteSearchOutput').jstree('destroy');
            $('#deleteSearchOutput').jstree({
                "core" : {
                    "animation" : 1,
                    "check_callback" : true,
                    "dots": true,
                    "icons": true,
                    "themes" : { "stripes" : true }
                },
                "types" : {
                    "leaf-node" : { "icon" : "fa fa-key fa-xs" }
                },
                'themes' : {
                    'responsive' : false,
                    'variant' : 'small',
                    'stripes' : true
                },

                "plugins" : [
                    "state", "types"
                ]
            });

            // load and refresh jstree
            $("#deleteSearchOutput").css("display", "block");
            $('#deleteSearchOutput').jstree(true).settings.core.data = treeData;
            $('#deleteSearchOutput').jstree(true).refresh();
            $('#deleteSearchOutput').jstree(true).show_all();
            $('#deleteSearchOutput').jstree("open_all");

            // construct the recycle bin path if not in the recycle bin path
            if (! secretPath.startsWith(VaultRecycleBinPath + FLDRCHR))
            {                
                $('#deleteToRecycleBin').css("display", "contents");
            }
            else // make sure you can't recursively recycle stuff in the recycle bin, this would be bad!
            {
                $('#deleteToRecycleBin').css("display", "none");                
                $('#deleteToRecycleChk').prop('checked', false);
            }

            // Trap the hover over node event and make it a selected item so as to trap the delete item event
            // and can delete the node upon a successful delete operation.
            $("#deleteSearchOutput").bind("hover_node.jstree", function (e, data)
            {
                $(this).jstree(true).deselect_all(true);
                $(this).jstree(true).select_node(data["node"]["a_attr"].id);
            });
            
            if (Object.keys(deleteItems).length > 1)
            {
                
            }

            if (VaultAbortSearch)
                return false;

            //  Display Warning about deleting an Item!
            var h = (window.innerHeight / 100) * 90;
            var w = (window.innerWidth  / 100) * 90;
            var deleteDialogBox = $("#deleteDialog").dialog({
                                    maxHeight: h,
                                    maxWidth:  w,
                                    width:     'auto',
                                    autoOpen:  false,
                                    modal:     true,
                                    show:      'fold',
                                    hide:      'fold',
                                    show:      {effect: 'fade', duration: 50},
                                    hide:      {effect: 'fade', duration: 50},
                                    title:     'Delete Operation: ' + secretName + secretPath,
                                    position: {of:       window,
                                               my:       'left top',
                                               at:       'left+20 top+90',
                                               collision:'none'
                                              },
                                    close:    function ()
                                              {
                                                  $(this).dialog("close");
                                                  if (element)
                                                  {
                                                      $(element).addClass("fa-trash-alt");
                                                      $(element).removeClass("fa-cog");
                                                      $(element).removeClass("fa-spin");
                                                  }
                                              },
                                    buttons : [{   text: "Delete Secrets",
                                                   click: function ()
                                                   {
                                                       // Save current path in VAULT UI.
                                                       var vuiVals = vault_pathURLtoNamePath (VaultCurrentURL)
                                                       var vuiName = unescape(vuiVals[0]);
                                                       var vuiPath = unescape(vuiVals[1]);

                                                       var delCount = nodeDeleteCountDict (deleteItems);
                                                       $.when(confirmDeleteOperation ('Confirm deletion of ' + delCount + ' items from ' + secretName + secretPath + '...'), $(deleteDialogBox) ).then(function(status)
                                                       {
                                                           status = status.toLowerCase();
                                                           if (status == "yes")
                                                           {
                                                                $("#deleteSearchOutput").css("display", "none");

                                                                var treeInst = $('#searchOutput').jstree(true);
                                                                var deletedCurrentURL = false;
                                                                var delMsg            = "";

                                                                // loop through deletion paths list ...
                                                                for(var key in pathParamList)
                                                                {
                                                                    var path       = key;
                                                                    var secretName = pathParamList[key].scrtName;
                                                                    var secretPath = pathParamList[key].scrtPath;
                                                                    var secretVer  = pathParamList[key].scrtVersion;
                                                                    var delItems   = pathParamList[key].delItems;

                                                                    // Clone to Recycle Bin...
                                                                    if ($('#deleteToRecycleChk').is(":checked"))
                                                                    {
                                                                        // move secrets operation to recycle bin ...
                                                                        var list = secretPath.split(FLDRCHR);
                                                                        var recycleBinPath = VaultRecycleBinPath + FLDRCHR + secretPath.replaceAll('/', '__') + '_' + gfNowTimeStamp()
                                                                        dbgInfo ("recyclebin item : " + secretName + secretPath + "  -->  " + recycleBinPath);
                                                                        var success = cloneRenameMoveSecret (true, secretName, secretPath, secretName,  recycleBinPath, true);
                                                                        $(deleteDialogBox).dialog('close');
                                                                        if (! success)
                                                                            return;
                                                                    }
                                                                    else // delete operation ...
                                                                    {
                                                                    
                                                                        nodeDeleteDict (VaultAddr, token, delItems);
                                                                        $(deleteDialogBox).dialog('close');
                                                                    }

                                                                    // Remove the deleted item/node from jstree, if the ThisSrchResultsDialogBox is active
                                                                    if (ThisSrchResultsDialogBox)
                                                                    {
                                                                        try
                                                                        {
                                                                            switch (operType)
                                                                            {
                                                                                case "single":
                                                                                    // Update the search output tree, and remove the now deleted nodes.
                                                                                    $("#searchOutput").jstree(true).delete_node($("#searchOutput").jstree(true).get_selected());
                                                                                    break;

                                                                                case "chkbox":
                                                                                    // Update the search output tree, and remove the now deleted nodes.
                                                                                    $.each($('#searchOutput').jstree("get_checked",null,true), function ()
                                                                                    {
                                                                                        var node = treeInst.get_node(this);

                                                                                        if (typeof node.data.scrtName == "undefined")
                                                                                            return; // ignore this data structure.

                                                                                        if ((node.data.scrtName + node.data.scrtPath) == key)
                                                                                            $("#searchOutput").jstree(true).delete_node(node);
                                                                                    });
                                                                                    break;
                                                                            }
                                                                        }
                                                                        catch(err)
                                                                        {
                                                                            dbgError ("nodeDeleteItem(1): Failed to prune #searchOutput tree : " + err);
                                                                            try { ThisSrchResultsDialogBox.dialog("close"); } catch(err) { }
                                                                        }
                                                                    }

                                                                    if ((vuiName == secretName) && (vuiPath == secretPath))
                                                                        deletedCurrentURL = true;

                                                                    delMsg += (delMsg != "" ? "<br>" : "");
                                                                    delMsg += ("Deleted:" + secretName + secretPath);
                                                                }


                                                                // prune any empty items/child items that are not leaf nodes from the searchOutput tree/dialog.
                                                                if (ThisSrchResultsDialogBox)
                                                                {
                                                                    try
                                                                    {
                                                                        $('#searchOutput li').each(function (index,value)
                                                                        {
                                                                            var node = $("#searchOutput").jstree().get_node(this.id);
                                                                            if ((node.children.length == 0) && (node.data.isLeafNode == false))
                                                                            {
                                                                                console.log('Purging node id = ' + this.id + ' : ' + node.data.scrtName + node.data.scrtPath);
                                                                                $("#searchOutput").jstree(true).delete_node(node);
                                                                            }
                                                                        });
                                                                    }
                                                                    catch(err)
                                                                    {
                                                                        dbgError ("nodeDeleteItem(2): Failed to prune #searchOutput tree : " + err);
                                                                        try { ThisSrchResultsDialogBox.dialog("close"); } catch(err) { }
                                                                    }
                                                                }

                                                                noteNorm (delMsg);

                                                                // Move up the current path if an item has been deleted!
                                                                setTimeout(function()
                                                                {
                                                                    (async () =>
                                                                    {
                                                                        refreshGotoURI (vaultParentPath (vuiName + vuiPath)); // go down one directory area upon a successful delete op of the Vault UI is in this location.
                                                                    })();
                                                                }, 1000);
                                                           }
                                                           else
                                                           {
                                                                if (element)
                                                                {
                                                                    $(element).addClass("fa-trash-alt");
                                                                    $(element).removeClass("fa-cog");
                                                                    $(element).removeClass("fa-spin");
                                                                }
                                                                return;
                                                           }
                                                       });
                                                   },
                                                   class:"",
                                                   style:"background-color:Red;color:white"
                                               },
                                               {   text: "No!",
                                                   click: function ()
                                                   {
                                                       dbgInfo ("No Called!");
                                                       $(this).dialog("close");
                                                       if (element)
                                                       {
                                                           $(element).addClass("fa-trash-alt");
                                                           $(element).removeClass("fa-cog");
                                                           $(element).removeClass("fa-spin");
                                                       }
                                                   },
                                                   class:""
                                               }]
                                });

            $("#deleteDialog").prev(".ui-dialog-titlebar").css("background-color","red");
            $("#deleteDialog").prev(".ui-dialog-titlebar").css("color","white");
            $("#deleteDialog").prev(".ui-dialog-buttonpane").css("background-color","darkred");
            $("#deleteDialog").dialog('open');

            // Hide pacifier
            vaultActionStartEnd (true);
        })();
    }, 100);
}

function confirmDeleteOperation (title, parentWin=window, fontCol="white", backgroundCol="red")
{
    var def = $.Deferred();
    $("#deleteConfirmFld").val("");
    $("#deleteConfirmDialog").dialog({
            autoOpen: false,
            width: 'auto',
            modal: true,
            title: title,
            position: {of:       parentWin,
                       my:       'left top',
                       at:       'left+40 top+130',
                       collision:'none'
                      },
            close: function () {
                $(this).dialog("close");
                def.resolve("no");
            },
            buttons: [{text: "Commit Delete",
                       click: function() {
                                  if ($("#deleteConfirmFld").val().toLowerCase() != "delete")
                                  {
                                      noteError ("type DELETE to commit deletion!");
                                      def.resolve("no");
                                  }
                                  else
                                  {
                                      def.resolve("yes");
                                  }
                                  $(this).dialog("close");
                            },
                      style:"background-color:" + backgroundCol + ";color:" + fontCol,
                      id: "commitDeleteButton"
                     },
                     {text:"Cancel",
                      click:function() {
                                $(this).dialog("close");
                                def.resolve("no");
                            }
                    }
                ]
    });

    $('#deleteConfirmDialog').keyup(function(e) {
        if (e.keyCode == $.ui.keyCode.ENTER)
            $('#commitDeleteButton').click();
    });

    $("#deleteConfirmDialog").prev(".ui-dialog-titlebar").css("background-color", backgroundCol);
    $("#deleteConfirmDialog").prev(".ui-dialog-titlebar").css("color", fontCol);
    $("#deleteConfirmDialog").dialog('open');
    return def.promise();
}

function confirmRemoveOperation (title, parentWin=window, fontCol="white", backgroundCol="red")
{
    var def = $.Deferred();
    $("#removeConfirmFld").val("");
    $("#removeConfirmDialog").dialog({
            autoOpen: false,
            width: 'auto',
            modal: true,
            title: title,
            position: {of:       parentWin,
                       my:       'left top',
                       at:       'left+40 top+130',
                       collision:'none'
                      },
            close: function () {
                $(this).dialog("close");
                def.resolve("no");
            },
            buttons: [{text: "Commit Remove",
                       click: function() {
                                  if ($("#removeConfirmFld").val().toLowerCase() != "remove")
                                  {
                                      noteError ("type REMOVE to commit removal!");
                                      def.resolve("no");
                                  }
                                  else
                                  {
                                      def.resolve("yes");
                                  }
                                  $(this).dialog("close");
                            },
                      style:"background-color:" + backgroundCol + ";color:" + fontCol,
                      id: "commitRemoveButton"
                     },
                     {text:"Cancel",
                      click:function() {
                                $(this).dialog("close");
                                def.resolve("no");
                            }
                    }
                ]
    });

    $('#removeConfirmDialog').keyup(function(e) {
        if (e.keyCode == $.ui.keyCode.ENTER)
            $('#commitRemoveButton').click();
    });

    $("#removeConfirmDialog").prev(".ui-dialog-titlebar").css("background-color", backgroundCol);
    $("#removeConfirmDialog").prev(".ui-dialog-titlebar").css("color", fontCol);
    $("#removeConfirmDialog").dialog('open');
    return def.promise();
}


// return an 2 element array as [true/false (matched element), element id] (.e. [true, "treefld123"])
function nodeSelectFolderSelectPath (treeID, treeData, matchPath)
{
    var pathNodes = matchPath.split(FLDRCHR);
    if ((pathNodes == null) || (pathNodes[0] == ""))
        return [false, ""];

    for (var k in treeData)
    {
        var name = treeData[k]["name"];
        if (name.toLowerCase() == pathNodes[0].toLowerCase())
        {
            var selectItem = nodeSelectFolderSelectPath (treeID, treeData[k]["children"], matchPath.split(FLDRCHR).splice(1).join(FLDRCHR)); // if return false, then select this node and child node was not matched!
            selectItem[0] = ! selectItem[0];
            if (selectItem[0])
            {
                dbgInfo ("nodeSelectFolderSelectPath: Selecting item " + treeData[k]["id"]);
                $(treeID).jstree(true).select_node(treeData[k]["id"], true);

                treeData[k]["state"] = {"opened" : true };
                selectItem[1] = treeData[k]["id"];
            }

            return [true, selectItem[1]];
        }
    }
    return [false, ""];
}

// selType = 0 : guess folder or all 
//           1 : all
//           2 : folder
function nodeSelectFolder (parentElement, path='', selType=0)
{
    var def   = $.Deferred();
    var token = vaultToken();
    dbgTrace ("token = " + token);

    if (token == null)
    {
        noteError ("Please Login before search can be used.");
        return false;
    }

    setTimeout(function()
    {
        (async () =>
        {
            VaultAbortSearch = false;

            var matchFolderType = selType;
                        
            if (matchFolderType == 0) // if in auto detect mode ... 
            {
                matchFolderType = 1
                if (vaultIsFolderPath(path)) // scan for folders only, if source path is of type folder
                    matchFolderType = 2;
            }
            
            var rtnData = await vault_FetchQueryRootMounts (VaultAddr, token, '', '', '', matchFolderType);

            if ((rtnData == null) || (Object.keys(rtnData).length <= 0))
            {
                dbgError ("nodeSelectFolder : vault_FetchQueryRootMounts something went wrong!");
                def.resolve("");
                return false;
            }

            var treeData = null;
            
            if (matchFolderType == 1)            
                treeData = vault_jsTreeAllDict (rtnData, false, path);
            else            
                treeData = vault_jsTreeFolderDict (rtnData, false, path);
            
            
            $('#folderSelectOutput').jstree('destroy');
            $('#folderSelectOutput').jstree({
                "core" : {
                    "animation" : 1,
                    "check_callback" : true,
                    "dots": true,
                    "icons": true,
                    "themes" : { "stripes" : true }
                },
                "types" : {
                    "leaf-node" : { "icon" : "fa fa-key fa-xs" }
                },
                'themes' : {
                    'responsive' : false,
                    'variant' : 'small',
                    'stripes' : true
                },

                "plugins" : [
                    "state", "types"
                ]
            });

            $("#folderSelectOutput").css("display", "block");
            $('#folderSelectOutput').jstree(true).clear_state();
            $('#folderSelectOutput').jstree(true).settings.core.data = treeData;
            $('#folderSelectOutput').jstree(true).deselect_all(true);
            $('#folderSelectOutput').jstree(true).refresh();

            var selectedItemID = ""
            $("#folderSelectOutput").bind("ready.jstree", function (e, data)
            {
                selectedItemID = (nodeSelectFolderSelectPath ('#folderSelectOutput', treeData, path)[1]);
                $('#folderSelectOutput').jstree(true).refresh();
            });

            $("#folderSelectOutput").bind("after_open.jstree", function (e, data)
            {
                // try until it succeed to scroll to the item in a jtree!
                try {
                    if (selectedItemID != "")
                    {
                        $('#folderSelectDialog').animate({
                                scrollTop: $('#' + selectedItemID).offset().top - ($('#folderSelectOutput').offset().top)
                        }, 800);
                    }
                    selectedItemID = "";
                } catch (err) {}
                dbgInfo ("redraw Called!");
            });

            var h = (window.innerHeight / 100) * 90;
            var w = (window.innerWidth  / 100) * 90;
            var folderSelectDialogBox = $("#folderSelectDialog").dialog({
                                    maxHeight: h/2,
                                    maxWidth:  w,
                                    width:     'auto',
                                    autoOpen:  false,
                                    modal:     true,
                                    show:      'fold',
                                    hide:      'fold',
                                    show:      {effect: 'fade', duration: 50},
                                    hide:      {effect: 'fade', duration: 50},
                                    title:     'Select Folder' + (matchFolderType == 1 ? '/Secret' : ''),
                                    position: {of:       $(parentElement),
                                               my:       'left top',
                                               at:       'left+25 top',
                                               collision:'none'
                                              },
                                    open:     function ()
                                              {
                                              },
                                    close:    function ()
                                              {
                                                  $(this).dialog("close");
                                                  def.resolve("");
                                              },
                                    buttons : [{   text: 'Select Folder' + (matchFolderType == 1 ? '/Secret' : ''),
                                                   click: function ()
                                                   {
                                                      dbgInfo ("Select Folder Called!");

                                                      $(this).dialog("close");
                                                      var s = $('#folderSelectOutput').jstree(true).get_selected();
                                                      var p = "";
                                                      if (s)
                                                      {
                                                          let n = $('#folderSelectOutput').jstree(true).get_node(s[0]);
                                                          if (n)
                                                              p = n['data'].scrtName + n['data'].scrtPath;
                                                      }

                                                      def.resolve(p);
                                                   },
                                                   class:"",
                                                   style:"background-color:blue;color:white"
                                               },
                                               {   text: "Cancel",
                                                   click: function ()
                                                   {
                                                      dbgInfo ("Cancel Called!");
                                                      $(this).dialog("close");
                                                      def.resolve("");
                                                   },
                                                   class:""
                                               }]
                                });

            $("#folderSelectDialog").prev(".ui-dialog-titlebar").css("background-color","blue");
            $("#folderSelectDialog").prev(".ui-dialog-titlebar").css("color","white");
            $("#folderSelectDialog").prev(".ui-dialog-buttonpane").css("background-color","darkblue");
            $("#folderSelectDialog").dialog('open');
        })();
    }, 100);

    return def.promise();
}

function nodeSelectFolderInput (container, destElement,  path='', busyElement='', selType=0)
{
    if (container)
    {
        $(container).find('input, textarea, button, select, a').prop('disabled', true);
        $(container).dialog('widget').find('button').prop('disabled', true);
    }

    if (busyElement)
    {
        var saveCSS =  $(busyElement).attr("class");
        $(busyElement).attr("class", "fas fa-cog fa-spin");
    }

    $.when(nodeSelectFolder (busyElement, path, selType)).then(function(selFolderPath)
    {
        if (container)
        {
            $(container).find('input, textarea, button, select, a').prop('disabled', false);
            $(container).dialog('widget').find('button').prop('disabled', false);
        }

        if (busyElement)
            $(busyElement).attr("class", saveCSS);

        if (selFolderPath != "")
            $(destElement).val(selFolderPath);
        console.log ("nodeSelectFolder returned : " + selFolderPath);
    });
}

async function vault_SecretsVersion (addr, token, name)
{
    return await (async () =>
    {
        // Activate the search cache
        if (token != null)
            await addReqCache ("token", token);
        else
        {
            dbgError ("vault_SecretsVersion: token is NULL!");
            return '';
        }

        var listURL     = addr + '/v1/sys/internal/ui/mounts';
        var jsonData    = null;
        var cache       = await getReqCache (listURL);
        if (cache[0])
            jsonData = cache[1];
        else
        {
            submitVaultAPIRequest (token, listURL, true);
            var cache = await getReqCache (listURL);
            if (cache[0])
                jsonData = cache[1];
            else
                return null;
        }

        dbgInfo ("vault_SecretsVersion: api call returned ...");

        if (! jsonData)
        {
            dbgError ("vault_SecretsVersion: jsonData is NULL!");
            return '';
        }

        if ("errors" in jsonData)
        {
            clrReqCache();
            dbgError  ("vault_SecretsVersion: Failed query on " + listURL );
            dbgError  ("vault_SecretsVersion: " + jsonData["errors"]);
            noteError ("Failed Vault Request.<br>Please try re-authentication or check Vault service.<br>"+jsonData["errors"]);
            return '';
        }

        // Make sure name has a trailing '/' for comparisons from json data
        if (name != '')
            name = gfRStrip(name, FLDRCHR) + FLDRCHR;

        var rtnData = { };
        var secrets=jsonData['data']['secret'];
        for (var key in secrets)
        {
            // dbgTrace (key + '::' + JSON.stringify(secrets[key]));
            var rsKey = gfRStrip(key, FLDRCHR);

            // if name is not null, and does not  matches mount point key, continue
            if ((name != '') && (name != key))
                continue;

            if (secrets[key]['type'] == 'kv')
            {
                return secrets[key]['options']['version'];
            }
            else if (secrets[key]['type'] == 'cubbyhole')
            {
                return '1';
            }
        }
        return '';
   })();
}

async function vault_RevokeTokenAccessor (addr, token, accessorID)
{
    var url = addr + '/v1/auth/token/revoke-accessor';
    var bdy = JSON.stringify({"accessor" : accessorID});
    var rtn = await fetch (url,{
                            method : 'POST',
                            headers: { "x-vault-token" : token },
                            cache: 'no-cache',
                            body:   bdy,
                          })
                          .then(response => response.json())
                          .then(data => {
                            return data;
                          })
                          .catch((error) => {
                               return null;
                          });
    return rtn;
}

async function vault_TokenAccessor (addr, token, accessorID=null)
{

    var url = addr + '/v1/auth/token/lookup-accessor';
    var bdy = JSON.stringify({"accessor" : accessorID});
    if (accessorID == null)
    {
         url = addr + '/v1/auth/token/lookup-self';
         bdy = '';
    }

    try
    {
        var rtn = await fetch (url,{
                                method : 'POST',
                                headers: { "x-vault-token" : token },
                                cache: 'no-cache',
                                body:   bdy,
                              })
                              .then(response => response.json())
                              .then(data => {
                                return data;
                              })
                              .catch((error) => {
                                   dbgWarn ("Failed vault_TokenAccessor(1):" + error);
                                   return null;
                              });
        if ("errors" in rtn)
        {
            dbgWarn ("Failed vault_TokenAccessor(2):" + rtn.errors[0]);
            return null;
        }
        return rtn;
    }
    catch (error)
    {
        dbgWarn ("Failed vault_TokenAccessor(3):" + error);
        return rtn;
    }
}

async function vault_QueryRootTokens (addr, token)
{
    var url = addr + '/v1/auth/token/accessors?list=true';
    var rtn = await fetch (url,{
                            method : 'GET',
                            headers: { "x-vault-token" : token },
                            cache: 'no-cache'
                          })
                          .then(response => response.json())
                          .then(data => {
                            return data;
                          })
                          .catch((error) => {
                               return null;
                          });

    var rootList = [];
    if (rtn && !("errors" in rtn))
    {
        var keys = rtn.data.keys;
        for (var idx=0; idx < keys.length; idx++)
        {
            var td = await vault_TokenAccessor (addr, token, keys[idx]);
            if (td && !("errors" in td))
            {
                if  (td.data.policies.indexOf("root") == 0)
                    rootList.push(td.data);
            }
        }
        return rootList;
    }
    return rtn;
}

async function vault_HasRootAccess (addr, token)
{
    if (token && addr)
    {
        var td = await vault_TokenAccessor (addr, token);
        if (td && !("errors" in td))
        {
            if  (td.data.policies.indexOf("root") == 0)
                return true;           
        }
    }
    return false;
}

async function vault_Status (addr, token)
{
    var url = addr + '/v1/sys/seal-status';
    var cache = await getReqCache (url);
    if (cache[0])
        return cache[1];
    else
    {
        submitVaultAPIRequest (token, url, false);
        cache = await getReqCache (url);
        if (cache[0])
            return cache[1];
    }
    return null;
}

// return:
// 0 = not match
// 1 = is folder
// 2 = is secret item
async function vault_ItemExists (addr, token, version, name, path)
{
    var rtnVals = await vault_FetchQueryKVSecrets (addr, token, version, name, path, '', false, 0, '', false, true);
    if ((rtnVals == null) || (Object.keys(rtnVals[1]).length === 0))
        return 0;
    if (vaultIsFolderPath(path))
        return 1;
    return 2;
}

async function vault_CloneWriteData (addr, token, version, name, path, dataTree)
{    
    dbgInfo ("vault_CloneWriteData pre-validate: '" + name + path + "'")
    let rtnPath = rtnValidPath (name, path);
    name = rtnPath[0];
    path = rtnPath[1];
    dbgInfo ("vault_CloneWriteData validated: '" + name + path + "'")  

    /* Given a path of systems/keepass/mysecret
          name        = systems/
          path        = keepass/mysecret
          isEndFolder = mysecret
          mysecret    = will contain leafdata in ["data"] item
    */
    // Write data operation
    return await (async () =>
    {
        for (var k in dataTree)
        {
            if ((dataTree[k]["child"] != null) && (dataTree[k]["isEndFolder"] == false))
            {
                var writePath = path;
                if (vaultIsFolderPath(writePath))
                    writePath = writePath + k;
                else
                    writePath = writePath + FLDRCHR + k;

                if (! await vault_CloneWriteData (addr, token, version, name, writePath, dataTree[k]["child"]))
                    return false;
            }
            else if (dataTree[k]["isEndFolder"])
            {
                // write data here ...
                var writeURL  = addr;
                var writePath = path;

                // if cloning data from end secret path to another end secret path (new name),
                // if destination is of type folder ('/'), then add the key name,
                // otherwise its not a folder, so use only the path name as the end name.
                if (vaultIsFolderPath(writePath))
                    writePath = writePath + k;

                if (version == '1')
                    writeURL = writeURL + '/v1/' + gfURLEncode(name + writePath);
                else if (version == '2')
                    writeURL = writeURL + '/v1/' + gfURLEncode(name + 'data/' + writePath);

                var secretJSON = '{"data":' + JSON.stringify(await Cryptoe.decrypt(dataTree[k]["data"])) + '}';
                var writeSuccess = await fetch(writeURL, {
                        method: 'POST',
                        headers: { "x-vault-token" : token },
                        cache: 'no-cache',
                        body: secretJSON
                    })
                    .then(data => {
                         if (data.status == 200)
                         {
                            dbgInfo('vault_CloneWriteData: Success:' + name + writePath);
                            return true;
                         }
                         dbgError  ("vault_CloneWriteData: Return status code != 200, got " + data.status);
                         dbgError  ("vault_CloneWriteData: Error failed request on " + writeURL);
                         noteError ("Bad Vault Response: Failed Vault CloneWriteData for: " + name + writePath);
                         return false;
                    })
                    .catch((error) => {
                            dbgError  ("vault_CloneWriteData: Error failed request on " + writeURL);
                            dbgError  ("vault_CloneWriteData: " + error);
                            noteError ("Exception: Failed Vault CloneWriteData for: " + name + writePath);
                            return false;
                   });

                // ok to continue clone process ?
                if (! writeSuccess)
                    return false;
            }
        }
        return true;
    })();
}

async function cloneRenameMoveSecret (moveRenameOper, srcName, srcPath, destName, destPath, forceOper=false)
{
    return await (async () =>
    {
        const cloneType = {LEAF:0, FOLDER:1};

        // clone type operation ... leaf/folder
        var srcType  = cloneType.LEAF;
        var destType = cloneType.LEAF;

        // review path types ...
        if (vaultIsFolderPath(srcPath))
            srcType = cloneType.FOLDER;

        if (vaultIsFolderPath(destPath))
            destType = cloneType.FOLDER;

        // some error checking on destination folders, is source is of type folder, destination path needs to as well!
        if ((srcType == cloneType.FOLDER) && (destType != cloneType.FOLDER))
        {
            destPath += FLDRCHR;
            destType = cloneType.FOLDER;
        }

        // check session
        var token = vaultToken();
        dbgTrace ("token = " + token);

        if (token == null)
        {
            noteError ("Please Login before clone operation can be used.");
            return false;
        }

        vaultActionStartEnd ();

        // Determine source version and destination version!
        var srcVersion  = await vault_SecretsVersion (VaultAddr, token, srcName);
        var destVersion = await vault_SecretsVersion (VaultAddr, token, destName);

        if (srcVersion == '')
        {
            noteError ("Unable to find source mount point '" + srcName + "' or unsupported secret type/version!");
            vaultActionStartEnd (true);
            return false;
        }

        if (destVersion == '')
        {
            noteError ("Unable to find destination mount point '" + destName + "' or unsupported secret type/version!");
            vaultActionStartEnd (true);
            return false;
        }

        // some error checking on destination folders, make sure destination is not in source
        if ((srcType == cloneType.FOLDER) && (destType == cloneType.FOLDER) && (destPath.match('^' + gfEscapeRegExp(srcPath))))
        {
            noteError ("Destination folder clone path '" + destPath + "' cannot be within the Source folder clone path '" + srcPath + "'");
            vaultActionStartEnd (true);
            return false;
        }

        // determine if destination path already exists, and if so then adjust destination path if necessary
        var destExist = await vault_ItemExists (VaultAddr, token, destVersion, destName, destPath);
        if (destExist)
        {
            if  (! forceOper)
            {
                if (! confirm('Destination Path Already Exists: ' + rtnValidPath (destName, destPath).join('') + '\nOk to overwrite matching data at this location?'))
                {
                    vaultActionStartEnd (true);
                   return false;
                }
            }

            // is folder type, then copy last part of source path name to destination path name
            // example:
            //    src : blah/data to clone/
            //    dest: blah/dest/
            // convert to:
            //    dest: blah/dest/data to clone/
            if ((destExist == 1) && (srcType == cloneType.FOLDER))
            {
                var list = gfRStrip(srcPath, FLDRCHR).split(FLDRCHR);
                var srcItemName = list.slice(-1)[0];
                if (srcItemName == "")
                    srcItemName = "-- CLONED OPER --";

                destPath += srcItemName + FLDRCHR;
            }
        }

        var rtnVals = await vault_FetchQueryKVSecrets (VaultAddr, token, srcVersion, srcName, srcPath, '', false, 0, '', true, true);
        if ((rtnVals == null) || (Object.keys(rtnVals[1]).length === 0))
        {
            dbgError  ("cloneRenameMoveSecret : vault_FetchQueryKVSecrets something went wrong!");
            noteError ("Clone operation failed to load source path!<br>Source Path =" + srcName + srcPath);
            vaultActionStartEnd (true);
            return false;
        }

        // check for blank destination path, if needs to exist!
        if (destPath == "")
        {
            // example:
            //    src : blah/data to clone/
            //    dest: blah/
            // convert to:
            //    dest: blah/data to clone
            var list = gfRStrip(srcPath, FLDRCHR).split(FLDRCHR);
            var srcItemName = list.slice(-1)[0];
            if (srcItemName == "")
                srcItemName = "-- CLONED OPER --";

            destPath = srcItemName;
        }

        var dataTree        = rtnVals[1];
        var moveRenameCount = nodeDeleteCountDict (dataTree);
        if ((moveRenameOper) && (moveRenameCount >= 4) && (! forceOper))
        {
             if (confirm('Confirm rename/move of ' + moveRenameCount + ' items from:\n' + rtnValidPath (srcName, srcPath).join('') + '\nto\n' + rtnValidPath (destName, destPath).join('')))
             {
                 if (await vault_CloneWriteData (VaultAddr, token, destVersion, destName, destPath, dataTree))
                 {

                     nodeDeleteDict (VaultAddr, token, dataTree);
                     vaultActionStartEnd (true);
                     return true;
                 }
             }
         }
         else if (moveRenameOper)
         {
             if (await vault_CloneWriteData (VaultAddr, token, destVersion, destName, destPath, dataTree))
             {
                 nodeDeleteDict (VaultAddr, token, dataTree);
                 vaultActionStartEnd (true);
                 return true;
             }
         }
         else
         {

             var rtn =  await vault_CloneWriteData (VaultAddr, token, destVersion, destName, destPath, dataTree);
             vaultActionStartEnd (true);
             return rtn;
         }
         vaultActionStartEnd (true);
         return false;
    })();
}

function clrClipAction ()
{
    $("#clipOperation").text('');
    $("#clipVaultSrcPath").text('');
    $("#clipCutCopyView").css("visibility", "collapse");
    $("#clipCutCopyView").css("display",    "none");
}

function rtnValidPath (name, path)
{
    name = unescape(name);
    path = unescape(path).split('?')[0];
    
    // # weed out /mountpoint/ /secret path/ -to-> /mountpoint/ /secret path/ -to-> /mountpoint//secret path/
    // convert    /mountpoint/ /secret path/ -to-> /mountpoint/ secret path/  -to-> /mountpoint/secret path/
    if ( ((name.length > 0) && (path.length > 0)) && 
         (name[name.length-1] == FLDRCHR) && (path[0] == FLDRCHR) )
    {
        path = gfTrimLeft(path, FLDRCHR);            
    }    
    return [name, path];    
}
function rtnCutCopyCurrentPath ()
{
    let rtnVals = vault_pathURLtoNamePath (VaultCurrentURL);
    return rtnValidPath (rtnVals[0], rtnVals[1]).join('');
}

// oper:
//  cut (current path)
//  copy (current path)
function cutCopyAction (oper, operPaths = "", parentWin = '')
{
    // check session
    var token = vaultToken();
    if (token == null)
    {
        noteError ("Please Login before " +  oper + " operation can be used.");
        return false;
    }

    var action = "";

    // Load settings into clipboard view
    if ((operPaths == null) || (operPaths == ""))
    {
        operPaths = rtnCutCopyCurrentPath ();
        if ((operPaths) == "")
            return;
    }

    switch (oper)
    {
        case "cut":
            parentWin = $('#cut-action');
            break;

        case "cut-chkbox":
            oper = "cut";
            break;

        case "copy":
            parentWin = $('#copy-action');
            break;

        case "copy-chkbox":
            oper = "copy";
            break;
    }

    if ($("#clipVaultSrcPath").text() != "")
    {
            var h = (window.innerHeight / 100) * 90;
            var w = (window.innerWidth  / 100) * 90;
            var addReplaceDialogBox = $("#copyPasteAddReplaceDialog").dialog({
                                    maxHeight: h,
                                    maxWidth:  w,
                                    minHeight: 'auto',
                                    width:     'auto',
                                    height:    'auto',
                                    autoOpen:  false,
                                    modal:     true,
                                    show:      'fold',
                                    hide:      'fold',
                                    show:      {effect: 'fade', duration: 50},
                                    hide:      {effect: 'fade', duration: 50},
                                    dialogClass: "custom-no-titlebar",
                                    title:     'Add / Replace Item?',
                                    position: {of:       parentWin,
                                               my:       'center top',
                                               at:       'center top+20',
                                               collision:'none'
                                              },
                                    close:    function ()
                                              {
                                                  $(this).dialog("close");
                                                  action = "";
                                              },
                                    buttons : [{   text: "Replace",
                                                   click: function ()
                                                   {
                                                        $("#clipOperation").text(oper);
                                                        $("#clipVaultSrcPath").text(operPaths);
                                                        $("#clipCutCopyView").css("visibility", "visible");
                                                        $("#clipCutCopyView").css("display",    "contents");
                                                        $(this).dialog("close");
                                                   },
                                                   class:"",
                                                   style:"background-color:skyblue;color:white"
                                               },
                                               {   text: "Append",
                                                   click: function ()
                                                   {
                                                        $("#clipOperation").text(oper);

                                                        // Append, sort unique into new list
                                                        var unqList = $("#clipVaultSrcPath").text().split('\n');
                                                        unqList=unqList.concat(operPaths.split('\n'));
                                                        var uniqueAndSorted = [...new Set(unqList)].sort()

                                                        // remove blank lines
                                                        uniqueAndSorted = uniqueAndSorted.filter(function(e){return e});

                                                        $("#clipVaultSrcPath").text(uniqueAndSorted.join('\n'));

                                                        $("#clipCutCopyView").css("visibility", "visible");
                                                        $("#clipCutCopyView").css("display",    "contents");
                                                        $(this).dialog("close");
                                                   },
                                                   class:"",
                                                   style:"background-color:blue;color:white"
                                               },
                                               {   text: "Cancel",
                                                   click: function ()
                                                   {
                                                        $(this).dialog("close");
                                                   },
                                                   class:"",
                                                   style:"background-color:red;color:white"
                                               }],
                                   focus: function() {
                                              $(this).siblings('.ui-dialog-buttonpane').find('button:eq(2)').focus();
                                          }
                                });
            addReplaceDialogBox.dialog('open');
    }
    else
    {
        $("#clipOperation").text(oper);
        $("#clipVaultSrcPath").text(operPaths);
        $("#clipCutCopyView").css("visibility", "visible");
        $("#clipCutCopyView").css("display",    "contents");
    }
}

async function pasteAction ()
{
    // check session
    var token = vaultToken();
    if (token == null)
    {
        noteError ("Please Login before paste operation can be used.");
        return false;
    }

    return await (async () =>
    {
        var rtnVals  = vault_pathURLtoNamePath (VaultCurrentURL);
        var pasteBaseName = unescape(rtnVals[0]);
        var pasteBasePath = unescape(rtnVals[1]);

        if ($("#clipCutCopyView").css("visibility") != "visible")
        {
            noteError ("Use Cut or Copy actions first before paste!");
            return;
        }

        vaultActionStartEnd (true);

        // loop through cut/copy list ...
        var cutCopyList = $("#clipVaultSrcPath").text().split("\n");
        var forceOper   = false;
        var oper        = $("#clipOperation").text().toLowerCase();
        for (var idx = 0; idx < cutCopyList.length; idx++)
        {
            var list        = cutCopyList[idx].split(FLDRCHR);
            var srcBaseName = list[0] + FLDRCHR;
            var srcBasePath = gfLStrip(list.splice(1).join(FLDRCHR), FLDRCHR);

            // Check source settings ...
            if (cutCopyList[idx] == "")
            {
                noteError ("Cut/Copy path is blank!");
                vaultActionStartEnd (true);
                return;
            }

            if (pasteBaseName == "")
            {
                noteError ("Paste to Root Secrets Path is not supported!");
                vaultActionStartEnd (true);
                return;
            }
            
            dbgInfo ("Operation: " + oper);
            dbgInfo ("pasteAction: srcBaseName = '" + srcBaseName + "'");
            dbgInfo ("pasteAction: srcBasePath = '" + srcBasePath + "'");
            dbgInfo ("");
            dbgInfo ("pasteAction: pasteBaseName = '" + pasteBaseName + "'");
            dbgInfo ("pasteAction: pasteBasePath = '" + pasteBasePath + "'");

            // ignore operations on the same src and dest path/name 
            if ( ((srcBaseName == pasteBaseName) && (srcBasePath == pasteBasePath) ) || 
                 ((srcBaseName == pasteBaseName) && (srcBasePath != '' && srcBasePath.match('^' + gfEscapeRegExp(pasteBasePath)))) )
            {
                dbgInfo ("pasteAction: operation ignored, as its the same src and dest path/name");
                continue;
            }
                
            var success = false;
            if (oper == "cut")
                success = await cloneRenameMoveSecret (true, srcBaseName, srcBasePath, pasteBaseName, pasteBasePath, forceOper);
            else if (oper == "copy")
                success = await cloneRenameMoveSecret (false, srcBaseName, srcBasePath, pasteBaseName, pasteBasePath, forceOper);
            else
            {
                noteError ("Unsupported Paste Operation: " + oper);
                vaultActionStartEnd (true);
                return;
            }

            if (success)
            {
                forceOper = true;
                clrReqCache(); // clear cache as it no longer reflects the new cloned items and VAULTS reality

                // Reload iframe on the last cut/copy operation
                if  (idx+1 >= cutCopyList.length)
                {
                    await (async () =>
                    {   
                        let cp = $("#vault_search_base_path").val();                    
                        refreshGotoURI (cp);
                        /************ does not always show changes results (i.e. results are cached)       
                        let cp = $("#vault_search_base_path").val();
                        vaultUIGotoPath ("");    
                        await new Promise(s => setTimeout(s, 100));                        
                        vaultUIGotoPath (cp);
                        *************/
                    })();
                }
            }
            else
                break;
        }

        if (oper == "cut")
            clrClipAction();
            
        vaultActionStartEnd (true);
    })();
}

function cloneMoveActionDialog (srcPath="", destPath="", cloneType="radio-clone", title="Clone/Move/Rename Operaton")
{
    // check session
    var token = vaultToken();
    if (token == null)
    {
        noteError ("Please Login before clone/move operation can be used.");
        return false;
    }

    srcPath  = unescape (srcPath);
    destPath = unescape (destPath);
    srcPath  = gfRStrip(gfLStrip(gfLStrip(srcPath, ' '), FLDRCHR), ' ');
    destPath = gfRStrip(gfLStrip(gfLStrip(destPath, ' '), FLDRCHR), ' ');

    if (cloneType)
        $("#" + cloneType).attr("checked", true);
    else
        $("#radio-clone").attr("checked", true);

    // if not destination path build one based upon source path type
    if (destPath == "")
    {
        if (vaultIsFolderPath(srcPath))
            destPath = gfRStrip(srcPath, FLDRCHR) + " - clone/";
        else
            destPath = srcPath + " - clone";
    }

    $("#cloneMoveDialog input[type='radio']" ).checkboxradio();
    $("#cloneMoveSrcld").val(srcPath);
    $("#cloneMoveDestld").val(destPath);


    var h = (window.innerHeight / 100) * 90;
    var w = (window.innerWidth  / 100) * 90;
    $("#cloneMoveDialog").dialog({
            autoOpen: false,
            width: (w * 0.8),
            modal: true,
            title: title,
            position: {of:       window,
                       my:       'auto top',
                       at:       'auto top+50',
                       collision:'none'
                      },
            close: function ()
                   {
                       $(this).dialog("close");
                   },
            buttons: [{text: "Commit Operation",
                       click:function()
                             {
                                 (async () =>
                                 {
                                     // check session
                                     var token = vaultToken();
                                     if (token == null)
                                     {
                                         noteError ("Please Login before clone/move operation can be used.");
                                         return;
                                     }

                                     var operSuccess = false;

                                     // Cleans the pathing and spaces
                                     srcPath  = gfRStrip(gfLStrip(gfLStrip($("#cloneMoveSrcld").val(), ' '), FLDRCHR), ' ');
                                     destPath = gfRStrip(gfLStrip(gfLStrip($("#cloneMoveDestld").val(),' '), FLDRCHR), ' ');

                                     var list         = srcPath.split(FLDRCHR);
                                     var srcParamName = list[0] + FLDRCHR;
                                     var srcParamPath = gfLStrip(list.splice(1).join(FLDRCHR), FLDRCHR);

                                         list          = destPath.split(FLDRCHR);
                                     var destParamName = list[0] + FLDRCHR;
                                     var destParamPath = gfLStrip(list.splice(1).join(FLDRCHR), FLDRCHR);

                                     dbgInfo ("cloneMoveActionDialog: cleansed srcPath = '" + srcPath + "'");
                                     dbgInfo ("cloneMoveActionDialog: srcParamName = '" + srcParamName + "'");
                                     dbgInfo ("cloneMoveActionDialog: srcParamPath = '" + srcParamPath + "'");
                                     dbgInfo ("");
                                     dbgInfo ("cloneMoveActionDialog: cleansed destPath = '" + destPath + "'");
                                     dbgInfo ("cloneMoveActionDialog: destParamName = '" + destParamName + "'");
                                     dbgInfo ("cloneMoveActionDialog: destParamPath = '" + destParamPath + "'");

                                     // check basic valid pathing
                                     if ((srcPath == "") || (srcParamName == ""))
                                     {
                                         noteError ("Invalidate Clone/Move Source Path!");
                                         return;
                                     }

                                     if ((destPath == "") || (destParamName == ""))
                                     {
                                         noteError ("Invalidate Clone/Move Destination Path!");
                                         return;
                                     }

                                     var success = await cloneRenameMoveSecret ($('#radio-move-rename').is(':checked'), srcParamName, srcParamPath, destParamName, destParamPath, false);
                                     if (success)
                                     {
                                         clrReqCache(); // clear cache as it no longer reflects the new cloned items and VAULTS reality
                                         if ($('#radio-move-rename').is(':checked'))
                                             noteNorm ("Move/Rename operation completed successfully!");
                                         else
                                             noteNorm ("Cloning operation completed successfully!");

                                         // GOTO new cloned location...          
                                        refreshGotoURI (destParamName + destParamPath);
                        
                                         // Example Vault UI links:
                                         //    Type Folder      : "/vault/secrets/systems/list/keepass/Access%2520Day%2520Cards/"
                                         //    Type Secret/Leaf : "/vault/secrets/systems/show/keepass/Access%2520Day%2520Cards/ITS%2520Contractor%2520Card%25201"
                                         // vaultUIGotoPath(destParamName + destParamPath);
                                         $(this).dialog("close");
                                     }

                                     // $(this).dialog("close");
                                 })();
                             },
                      style:"background-color:darkcyan;color:white"
                     },
                     {text:"Cancel",
                      click:function()
                            {
                                $(this).dialog("close");
                            }
                    }
                ]
    });

    $("#cloneMoveDialog").prev(".ui-dialog-titlebar").css("background-color","darkcyan");
    $("#cloneMoveDialog").prev(".ui-dialog-titlebar").css("color","white");
    $("#cloneMoveDialog").prev(".ui-dialog-buttonpane").css("background-color","darkcyan");
    $("#cloneMoveDialog").dialog('open');
}

function base64ToolsActionDialog ()
{
    var h = (window.innerHeight / 100) * 90;
    var w = (window.innerWidth  / 100) * 90;
    $("#base64ToolsDialog").dialog({
            autoOpen: false,
            width: (w * 0.8),
            modal: false,
            title: "Base64: Encode/Decode Secrets Data",
            position: {of:       window,
                       my:       'center top',
                       at:       'center top+130',
                       collision:'none'
                      },
            close: function ()
                   {
                       $(this).dialog("close");
                   }
    });

    $("#base64ToolsDialog").prev(".ui-dialog-titlebar").css("background-color","darkmagenta");
    $("#base64ToolsDialog").prev(".ui-dialog-titlebar").css("color","white");
    $("#base64ToolsDialog").prev(".ui-dialog-buttonpane").css("background-color","darkmagenta");
    $("#base64ToolsDialog").dialog('open');
}

function pwGeneratorActionDialog ()
{
    var h = (window.innerHeight / 100) * 90;
    var w = (window.innerWidth  / 100) * 90;

    $('#textarea_pwgeneratorOutput').val('');

    $("#pwGeneratorDialog").dialog({
            autoOpen: false,
            width: "auto",
            modal: false,
            title: "Password Generator",
            position: {of:       window,
                       my:       'center top',
                       at:       'center top+130',
                       collision:'none'
                      },
            close: function ()
                   {
                       pwGenerateSaveCookieSettings();
                       $(this).dialog("close");
                   }
    });

    $("#pwGeneratorDialog").prev(".ui-dialog-titlebar").css("background-color","darkgreen");
    $("#pwGeneratorDialog").prev(".ui-dialog-titlebar").css("color","white");
    $("#pwGeneratorDialog").prev(".ui-dialog-buttonpane").css("background-color","darkgreen");
    $("#pwGeneratorDialog").dialog('open');
}

function BecomeAsTokenWrapper (token)
{
    $('#sudo-token-login').val('');
    BecomeAsToken (token);
    $('#pwRootToolsDialog').dialog('close');
    setTimeout (function() { rootToolsActionDialog(); }, 10000);
    noteNorm('<span style="font-size:large">Please wait for automated login</span>', 9000);
}

async function BecomeAsToken (token)
{
    vaultUIGotoURI ("/vault/logout");
    await new Promise(s => setTimeout(s, 2000));

    vaultUIGotoURI ("/vault/auth?with=token");
    await new Promise(s => setTimeout(s, 2000));
    var maxTries = 10*2; // 10 seconds
    var pgTst    = setInterval(function()
    {
        var ifr = document.getElementById(FrameID);        
        var arr = getVaultEmberObj().__container__.lookup('-view-registry:main');
        maxTries--;        
        for (const [key, item] of Object.entries(arr))
        {
            if (item.hasOwnProperty('selectedAuth') && item['selectedAuth'] == "token")
            {  
                clearInterval(pgTst);
                item.token = token;     
                ifr.contentWindow.document.getElementById('auth-submit').click();
                return;
            }
        }
        
        if (maxTries < 0)
        {
            clearInterval(pgTst); // give up trying to match login token input field/control
            noteError ("Failed to login as requested token.");
        }
    }, 500);
}

function rootGenerateToken ()
{
    // '#textarea_pwRootToolsoutput'
    var token = vaultToken();
    dbgTrace ("token = " + token);
    if (token == null)
    {
        noteError ("Please Login before root tools can be used.");
        return false;
    }

    (async () =>
    {
        var vstatus = await vault_Status (VaultAddr, token);
        if (! vstatus)
            return;

        // test if all fields are non empty
        for (var idx = 0; idx < vstatus.t; idx++)
        {
            if ($('#root-seal-'+idx).val().trim() == '')
            {
                noteError ("Please populate all Vault recovery key fields.");
                return;
            }
        }

        var out = $('#textarea_pwRootToolsoutput');
        await fetch (VaultAddr + '/v1/sys/generate-root/attempt',{
                        method : 'DELETE',
                        headers: { "x-vault-token" : token },
                        cache: 'no-cache'
                      })
                      .then(response => response.json())
                      .then(data => {
                        return data;
                      })
                      .catch((error) => {
                           return null;
                      });

        // initialise start of the root token request, get otp (one time password)
        var initDetails = await fetch (VaultAddr + '/v1/sys/generate-root/attempt',{
                                        method : 'PUT',
                                        body:   JSON.stringify({"otp" : "" }),
                                        headers: { "x-vault-token" : token },
                                        cache: 'no-cache'
                                      })
                                      .then(response => response.json())
                                      .then(data => {
                                        return data;
                                      })
                                      .catch((error) => {
                                           return null;
                                      });

        dbgTrace ("initDetails response : " + JSON.stringify(initDetails,null,'    '));
        if (! initDetails)
        {
            noteError ("Failed root token initialisation");
            return;
        }

        if ("errors" in initDetails)
        {
            noteError ("Failed root token initialisation. " + initDetails.errors[0]);
            return;            
        }
        
        if (initDetails.nonce == "")
        {
            noteError ("Failed root token initialisation. nonce is blank!");
            return;
        }
        
        if (initDetails.otp == "")
        {
            noteError ("Failed root token initialisation. otp is blank!");
            return;
        }

        dbgTrace ("root init: response " + JSON.stringify(initDetails,null,'    ') );
        var genStep = null;
        for (var idx = 0; idx < vstatus.t; idx++)
        {
            genStep = await fetch (VaultAddr + '/v1/sys/generate-root/update',{
                                   method : 'PUT',
                                   body:   JSON.stringify({"nonce" : initDetails.nonce,
                                                           "key"   : $('#root-seal-'+idx).val().trim()}),
                                   headers: { "x-vault-token" : token },
                                   cache: 'no-cache'
                                  })
                                  .then(response => response.json())
                                  .then(data => {
                                    return data;
                                  })
                                  .catch((error) => {
                                       return null;
                                  });

            dbgTrace ("Unlock response[" + idx + "[ : " + JSON.stringify(genStep,null,'    '));

            if ((! genStep) || (genStep && (Number(genStep.progress) != idx+1)))
            {
                noteError ("Failed root token key unlock on field [" + idx+1 + "]");
                return;
            }
        }

        dbgTrace ("Unlocked code : " + JSON.stringify(genStep,null,'    '));

        // Decrypt the root token
        var rootEncypted = atob(genStep.encoded_root_token);
        var rootToken    = "";
        for (var idx = 0; idx < initDetails.otp.length; idx++)
            rootToken += String.fromCharCode(rootEncypted[idx].charCodeAt() ^ initDetails.otp[idx].charCodeAt())

        // remove all previous checks...
        $("#pwRoot-CheckAll").prop('checked', true);

        out.val(out.val() + rootToken + "\n");
        // auto login as this root token ?
        if ($('#pwRoot-AutoLogin').is(":checked"))
            BecomeAsTokenWrapper (rootToken);
        else
            $('#sudo-token-login').val(rootToken);

        // clear vault backup out keys ...
        for (var idx = 0; idx < vstatus.t; idx++)
            $('#root-seal-'+idx).val('');

    })();
}

function revokeRootTokens()
{
    // check session
    var token = vaultToken();
    dbgTrace ("token = " + token);
    if (token == null)
    {
        noteError ("Please Login before root tools can be used.");
        return false;
    }

    (async () =>
    {
        var thisTokenInfo        = await vault_TokenAccessor (VaultAddr, token);
        var thisTokenAccessor    = "";
        var delThisTokenAccessor = false;

        if (thisTokenInfo)
            thisTokenAccessor = thisTokenInfo.data.accessor;

        var success       = true;
        $('[id*=pwRoot-Check-Token-]').each(function(idx)
        {
            if (! $(this).prop('checked'))
                return;

            // Dont delete this token just yet, leave for last so as to be able to delete any other tokens in the .each list
            if ($(this).val() == thisTokenAccessor)
            {
                delThisTokenAccessor = true;
                return;
            }

            var t = vault_RevokeTokenAccessor  (VaultAddr, token, $(this).val());

            if (t && ("errors" in t))
            {
                success = false;
                noteError ("Failed revoking token accessor: " + $(this).val() + "<br>" + t.errors);
            }
            else if (!t)
            {
                success = false;
                noteError ("Failed revoking token accessor: " + $(this).val());
            }
        });

        if (delThisTokenAccessor)
        {
            var t = vault_RevokeTokenAccessor  (VaultAddr, token, thisTokenAccessor);

            if (t && ("errors" in t))
            {
                success = false;
                noteError ("Failed revoking token accessor: " + thisTokenAccessor + "<br>" + t.errors);
            }
            else if (!t)
            {
                success = false;
                noteError ("Failed revoking token accessor: " + thisTokenAccessor);
            }
        }

        if (success)
        {
            noteNorm ("Revoking root tokens completed!");

            // logout out of session as its no-longer valid, it has been revoked!
            if (delThisTokenAccessor)
                vaultUIGotoURI ("/vault/logout");
        }
    })();
}

function rootToolsActionDialog ()
{
    var h = (window.innerHeight / 100) * 90;
    var w = (window.innerWidth  / 100) * 90;

    // check session
    var token = vaultToken();
    dbgTrace ("token = " + token);
    if (token == null)
    {
        $("#pwRootToolsDialog").dialog('close');
        noteError ("Please Login before root tools can be used.");
        return false;
    }

    (async () =>
    {
        var vstatus = await vault_Status (VaultAddr, token);
        if (! vstatus)
            noteError ("Failed Vault status call!");
        else
        {
            dbgTrace ("Vault Status: " + JSON.stringify(vstatus,null,'    '));

            // Construct the required number of fields for root token generation
            $('#pwRootToolsSealNumReq tr').remove();
            for (var idx = 0; idx < vstatus.t; idx++)
                $('#pwRootToolsSealNumReq').find('tbody').append('<tr><td style="white-space:nowrap;text-align:right">[' +( idx+1) + FLDRCHR +  vstatus.t + ']</td><td style="white-space:nowrap;text-align:left;width:100%"><input type="text" id="root-seal-' + idx + '" max="1024" style="width:100%;font-family: monospace;"></td></tr>');
        }

        var thisTokenInfo = await vault_TokenAccessor    (VaultAddr, token);
        var curRootTokens = await vault_QueryRootTokens  (VaultAddr, token);
        var out           = $('#textarea_pwRootToolsoutput');

        $('#pwRootToolsCurrentRootTokens tr:not(:first)').remove();

        if (curRootTokens && !("errors" in curRootTokens))
        {
            for (var idx=0; idx < curRootTokens.length; idx++)
            {
                var matchedToThis = '';
                var cd            = new Date(0)
                cd.setUTCSeconds(curRootTokens[idx].creation_time);

                if (thisTokenInfo && (thisTokenInfo.data.accessor == curRootTokens[idx].accessor))
                    matchedToThis = " <b>*</b> ";

                var r = '<tr>' +
                        '<td style="white-space:nowrap"><input type="checkbox" id="pwRoot-Check-Token-' + idx + '" value="' + curRootTokens[idx].accessor + '" checked>' + matchedToThis + '</td>' +
                        '<td style="white-space:nowrap">' + curRootTokens[idx].display_name + '</td>' +
                        '<td style="white-space:nowrap">' + gfFormatDate(cd) + '</td>' +
                        '<td style="white-space:nowrap">' + (curRootTokens[idx].expire_time?curRootTokens[idx].expire_time: 0) + '</td>' +
                        '<td style="white-space:nowrap">' + curRootTokens[idx].policies + '</td>' +
                        '<td style="white-space:nowrap">' + curRootTokens[idx].accessor + '</td>' +
                        '</tr>';
                $('#pwRootToolsCurrentRootTokens').find('tbody').append(r);
            }
            $('#pwRootToolsCurrentRootTokens').find('tbody').append('<tr><td colspan="100%"><button class="ui-button ui-corner-all ui-widget" onclick="revokeRootTokens(); setTimeout (function() { rootToolsActionDialog(); }, 2000);">Revoke Checked Root Tokens</button>');
            $("#pwRoot-CheckAll").prop('checked', true);
        }
        else if (curRootTokens && ("errors" in curRootTokens))
        {
            $("#pwRoot-CheckAll").prop('checked', false);
            $('#pwRootToolsCurrentRootTokens').find('tbody').append('<tr><td colspan="100%">' + curRootTokens.errors + '</td></tr>');
        }

        $("#pwRootToolsDialog").dialog({
                autoOpen: false,
                width: "auto",
                modal: false,
                title: "Vault Root Tools",
                position: {of:       window,
                           my:       'center top',
                           at:       'center top+130',
                           collision:'none'
                          },
                close: function ()
                       {
                           $(this).dialog("close");
                       }
        });

        $("#pwRootToolsDialog").prev(".ui-dialog-titlebar").css("background-color","darkred");
        $("#pwRootToolsDialog").prev(".ui-dialog-titlebar").css("color","white");
        $("#pwRootToolsDialog").prev(".ui-dialog-buttonpane").css("background-color","darkred");
        $("#pwRootToolsDialog").dialog('open');
    })();
}

// genTYpe = "ascii", "hex"
function pwGenerate (genType)
{
    if (genType == "hex")
    {
        var caseType = $('input[name="pwgen-hexCase"]:checked').val();
        var hexChars = "01234567890abcdef";
        var pwLen    = $('#pwgen-pwHexLen').val();
        var pw       = "";
        for (var idx = 0; idx < pwLen; idx++)
        {
            let c = hexChars[Math.floor(Math.random() * hexChars.length)];
            if ( (caseType == "upper") || ((caseType == "both") && (Math.floor(Math.random() * 2))) )
                pw += c.toUpperCase();
            else
                pw += c;
        }

        $('#textarea_pwgeneratorOutput').val(pw);
    }
    else if (genType == "ascii")
    {
        var rndChars = "";
        if ($('#pwgen-pwASCIILowercase').is(":checked"))
            rndChars += "abcdefghijklmnopqrstuvwxyz";

        if ($('#pwgen-pwDigits').is(":checked"))
             rndChars += "0123456789";

        if ($('#pwgen-pwSpecials').is(":checked"))
            rndChars += "!@#$%^&*-+=\|:;.,/?_~";

        if ($('#pwgen-pwSpaces').is(":checked"))
            rndChars += " ";

        if ($('#pwgen-pwBrackets').is(":checked"))
            rndChars += "[]{}()<>";

        if ($('#pwgen-pwASCIIUppercase').is(":checked") || rndChars == "")
            rndChars += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        var pwLen = $('#pwgen-pwASCIILen').val();
        var pw    = "";
        for (var idx = 0; idx < pwLen; idx++)
            pw += rndChars[Math.floor(Math.random() * rndChars.length)];

        $('#textarea_pwgeneratorOutput').val(pw);
    }

    // auto copy into clipboard
    if ($('#pwgen-pwAutoCopyGenPW').is(":checked"))
    {
        gfCopyToClipboard($('#textarea_pwgeneratorOutput').val());
        noteNorm('Output copied to Clipboard');
    }

    return false;
}

function pwGenerateLoadCookieSettings ()
{
    dbgInfo ("Loading pwGenerateLoadCookieSettings...");
    try
    {
        var v = "";
        try
        {
            v = eval(gfGetCookie ("pwgen-pwASCIILen"))
            if ((v == undefined) || (v == ""))
                throw 'not set'
        } catch { v = 16 };
        $('#pwgen-pwASCIILen').val(v);

        $('#pwgen-pwASCIIUppercase').prop( "checked", eval(gfGetCookie ("pwgen-pwASCIIUppercase")));
        $('#pwgen-pwASCIILowercase').prop( "checked", eval(gfGetCookie ("pwgen-pwASCIILowercase")));
        $('#pwgen-pwSpaces').prop        ( "checked", eval(gfGetCookie ("pwgen-pwSpaces")));
        $('#pwgen-pwSpecials').prop      ( "checked", eval(gfGetCookie ("pwgen-pwSpecials")));
        $('#pwgen-pwDigits').prop        ( "checked", eval(gfGetCookie ("pwgen-pwDigits")));
        $('#pwgen-pwBrackets').prop      ( "checked", eval(gfGetCookie ("pwgen-pwBrackets")));

        v = "";
        try
        {
            v = eval(gfGetCookie ("pwgen-pwHexLen"))
            if ((v == undefined) || (v == ""))
                throw 'not set'
        } catch { v = 16 };
        $('#pwgen-pwHexLen').val(v);

        $("input[name=pwgen-hexCase][value=" + gfGetCookie ("pwgen-hexCase") + "]").prop('checked', true);

        $('#pwgen-pwAutoCopyGenPW').prop( "checked", eval(gfGetCookie ("pwgen-pwAutoCopyGenPW")));
    }
    catch
    {
        dbgInfo ("FAILED LOADING pwGenerateLoadCookieSettings!");
    }
}

function pwGenerateSaveCookieSettings ()
{
    var v = "";
    try
    {
        v = Math.abs($('#pwgen-pwASCIILen').val());
        if ((v == undefined) || (v == ""))
            throw 'not set'
    } catch { v = 16; };
    $('#pwgen-pwASCIILen').val(v);
    gfSetCookie ("pwgen-pwASCIILen",       String(v), 365);

    gfSetCookie ("pwgen-pwASCIIUppercase", String($('#pwgen-pwASCIIUppercase').is(":checked")), 365);
    gfSetCookie ("pwgen-pwASCIILowercase", String($('#pwgen-pwASCIILowercase').is(":checked")), 365);
    gfSetCookie ("pwgen-pwSpaces",         String($('#pwgen-pwSpaces').is(":checked")),         365);
    gfSetCookie ("pwgen-pwSpecials",       String($('#pwgen-pwSpecials').is(":checked")),       365);
    gfSetCookie ("pwgen-pwDigits",         String($('#pwgen-pwDigits').is(":checked")),         365);
    gfSetCookie ("pwgen-pwBrackets",       String($('#pwgen-pwBrackets').is(":checked")),       365);

    v = "";
    try
    {
        v = Math.abs($('#pwgen-pwHexLen').val());
        if ((v == undefined) || (v == ""))
            throw 'not set'
    } catch { v = 16 };
    $('#pwgen-pwHexLen').val(v);
    gfSetCookie ("pwgen-pwHexLen",         String(v), 365);

    gfSetCookie ("pwgen-hexCase",          String($('input[name="pwgen-hexCase"]:checked').val()), 365);
    gfSetCookie ("pwgen-pwAutoCopyGenPW",  String($('#pwgen-pwAutoCopyGenPW').is(":checked")),     365);
}

// build the vault_search_base_path
var BookmarkSecretPaths = [];
function pinAddRemoveSecretPathSelectBox (name=null, path=null)
{
    if (! name)
    {
        var rtnVals = vault_pathURLtoNamePath (VaultCurrentURL)
        name = rtnVals[0];
        path = rtnVals[1];    
    }
    
    name = unescape(name);
    path = unescape(path);        
    
    if ((name + path) != "")
    {
        var newbm = [];
        var fnd   = false;
        for (var idx = 0; idx < BookmarkSecretPaths.length; idx++)
        {
            if ((name + path) != BookmarkSecretPaths[idx])
            {
                newbm.push(BookmarkSecretPaths[idx]);
            }
            else
            {
                noteNorm ("Unpinned: " + name + path);
                fnd = true;
            }
        }
        BookmarkSecretPaths = newbm;
        if (! fnd)
        {
            noteNorm ("Pinned: " + name + path);
            BookmarkSecretPaths.push(name + path);
        }

        buildCurrentSecretPathSelectBox ();
        gfSetCookie ("sp-bookmarks",  String(JSON.stringify(BookmarkSecretPaths)), 365);
    }
}

function removeSecretPathSelectBoxItem (labelIdx)
{
    var updatePins = [];
    for (var idx=0; idx < BookmarkSecretPaths.length; idx++)
    {
        if (idx == labelIdx)
            noteNorm ("Unpinned: " + BookmarkSecretPaths[idx]);
        else
            updatePins.push(BookmarkSecretPaths[idx]);
    }

    BookmarkSecretPaths = updatePins;
    buildCurrentSecretPathSelectBox();
}

function buildCurrentSecretPathSelectBox ()
{
    var rtnVals = vault_pathURLtoNamePath (VaultCurrentURL)
    var name = unescape(rtnVals[0]);
    var path = unescape(rtnVals[1]).split('?')[0];
    var options = [];
    var selectedItem = "";
    options.push("<option value=''>" + ALLOFVAULT + "</option>");
    if (name != "")
    {
        selectedItem = name;
        options.push("<option value='" + selectedItem.replaceAll("'", "&#39;") + "'>" + name +"</option>");
    }

    if (path != "")
    {
        var sp = path.split(FLDRCHR);
        var opPath       = "";
        for (var idx = 0; idx < sp.length; idx++)
        {
            if (sp[idx] == "")
                continue;

            opPath = opPath + sp[idx] + FLDRCHR ;
            selectedItem = name + opPath;
            options.push("<option value='" + selectedItem.replaceAll("'", "&#39;") + "'>" + name + opPath + "</option>");
        }

        // Rebuild the last item if the last item is a leaf node without a '/' in the path
        // example if VaultCurrentURL = '/vault/secrets/systems/show/keepass/DBA/db_audit'
        // then option should be this: '<option value="systems/:keepass/DBA/uow_db_audit">systems/keepass/DBA/uow_db_audit</option>'
        // and NOT this:               '<option value="systems/:keepass/DBA/uow_db_audit/">systems/keepass/DBA/uow_db_audit/</option>'
        if (! vaultIsFolderPath(path))
        {
            options.pop();
            opPath       = gfRStrip(opPath, FLDRCHR);
            selectedItem = gfRStrip(selectedItem, FLDRCHR);
            options.push("<option value='" + selectedItem.replaceAll("'", "&#39;") + "'>" + name + opPath + "</option>");
        }
    }

    if (BookmarkSecretPaths.length > 0)
    {
        // This works as a separator
        options.push('<option value="-">-</option>');

        for (var idx = 0; idx < BookmarkSecretPaths.length; idx++)
            options.push("<option style='font-weight:bold' value='" + BookmarkSecretPaths[idx] + "'>" + BookmarkSecretPaths[idx] + SelectMenuLabelBrk + "</option>");
    }

    // update/refresh with new menu list parsed/constructed from the VAULT EMBER path
    $("#vault_search_base_path").children().remove();
    $("#vault_search_base_path").append(options);
    $('#vault_search_base_path').val(selectedItem); // dont replace quote chars here, its handled in the on change() of #vault_search_base_path
    $("#vault_search_base_path").superSelectMenu("refresh");

    $("#pin-secret-path-icon").css("color", "");
    if ((name + path) != "")
    {
        $("#pin-secret-path-icon").css("color", "darkgreen");
        for (var idx = 0; idx < BookmarkSecretPaths.length; idx++)
        {
            if ((name + path) == BookmarkSecretPaths[idx])
            {
                $("#pin-secret-path-icon").css("color", "red");
                break;
            }
        }
    }
}

// ===============================================================================================================

// Chk Logged in Status
setInterval(function()
{
    dbgTrace ("setInterval: Checking logged in status...");
    let chkToken = vaultToken();
    if ((chkToken == null) && (ThisSrchResultsDialogBox))
        delSearchDialog ();

}, VaultChkTime);


var CurrentBodyHeight     = 0;
var VaultCurrentURL       = "";
var VaultFocusUSERNAMEURL = "";

// Chk Navigation Path and things, UOW's interrupt handler for GUI checking
setInterval(function()
{
    try
    {
        // Update the drop down menu with the current path from VAULT's url in the EMBER document.
        var curl = getVaultEmberObj().__container__.lookup("service:-routing").router.currentURL;

        // Set the username input focus
        if (curl == VaultAuthURI)
        {
            if (VaultFocusUSERNAMEURL != curl)
            {
                let un =  $('#' + FrameID).contents().find('#username');
                if (un.length == 1) // Set focus of the username field if it exists as it's dynamically generated.
                {
                    dbgInfo ("Set  username input field focus");
                    VaultFocusUSERNAMEURL = curl;
                    un.focus();
                }
            }
        }
        else
        {
            VaultFocusUSERNAMEURL = "";
        }

        var token = vaultToken();
        
        // Detect if page has change and capture current Vault path.
        if (VaultCurrentURL != curl)
        {            
            // Hide cubbyhole reference, its just Gui noise...                        
            if (VaultGUIHideCubby && (curl == VaultBaseGUIURI))
            {   
                dbgTrace ("hiding cubby hole reference");
                var element = $('#' + FrameID).contents().find('a[href="' + DefaultPage + VaultBaseGUIURI + '/cubbyhole/list');
                while ((element.length > 0) && (element.parent().find('.container').length <= 0))
                {
                    if (element.parent().find('.list-item-row').length > 0)
                    {
                        element.hide();
                        break;
                    }
                    element = element.parent();
                }
            }

            VaultCurrentURL = curl;
            dbgInfo ("Current URL: " + VaultCurrentURL);
            var rtnVals = vault_pathURLtoNamePath (VaultCurrentURL)
            var name = unescape(rtnVals[0]);
            var path = unescape(rtnVals[1]).split('?')[0];
            dbgInfo ("Current URL: name:path | " + name + ":" + path);

            // build the vault_search_base_path list
            buildCurrentSecretPathSelectBox ();

            // Display the preview of destination path in the clipboard area
            $("#clipVaultDestPath").text (rtnCutCopyCurrentPath ());

            // Update progInfo-action icon to be enabled or disabled based upon the current Vault path
            if ((path == "") || path.endsWith(FLDRCHR))
            {
                // This is not an ending directory item/type so disable this icon
                $('#progInfo-action').attr("onclick","");
                $('#progInfo-action').removeClass('disabled-icon')
                $('#progInfo-action').addClass('disabled-icon');
            }
            else
            {
                // This is ending directory/path, so show/enable programming api info helper icon
                $('#progInfo-action').removeClass('disabled-icon')
                $('#progInfo-action').attr("onclick",'vault_generateCodeExample("' + gfURLEncode(VaultAddr + '/v1/' + name + 'data/' + path) + '");');
                dbgInfo ("prog info onclick : " + $('#progInfo-action').attr("onclick"));
            }
                        
            // Update root only access icons domainUsersGroups-action, vault-expimp-action
            (async () =>
            {
                let isRoot = await vault_HasRootAccess (VaultAddr, token);         
                if (isRoot)                        
                {
                    $('#domainUsersGroups-action').removeClass('disabled-icon')
                    $('#vault-expimp-action').removeClass('disabled-icon')
                }
                else
                {
                    $('#domainUsersGroups-action').removeClass('disabled-icon')
                    $('#domainUsersGroups-action').addClass('disabled-icon'); 

                    $('#vault-expimp-action').removeClass('disabled-icon')
                    $('#vault-expimp-action').addClass('disabled-icon');                 
                }
            })();
        }

        // resize main body of the window to suite the iframe loaded if token != null
        if (token)
        {
            if (CurrentBodyHeight != document.body.scrollHeight)
            {
                dbgTrace ("resizeIFrame: resize height=" +  document.body.scrollHeight);
                $("#framer").css ("height",  document.body.scrollHeight + "px");
                CurrentBodyHeight = document.body.scrollHeight;
            }
        }
        else // resize main body of the window to 100%
        {
            if (CurrentBodyHeight != "100%")
            {
                dbgTrace ("resizeIFrame: token null, set screen size to 100%");
                CurrentBodyHeight = "100%";
                $("#framer").css ("height", CurrentBodyHeight);
            }
        }
    }
    catch (err) {  } // ignore...
}, 500);

// Async check/load passwords into memory...
setInterval (function()
{
    AsyncCacheLoad ();
}, VaultAsyncChkLoadTime);


// ----- Upon Document Loaded EVENT ------
$(document).ready(function()
{
    // clear cached data
    window.onbeforeunload = function() 
    {
        clrReqCache ()
    };

    // Implement custom select menu to implement '-' menu items as menu separator as it shouold be for normal menu items
    $.widget( "custom.superSelectMenu", $.ui.selectmenu,
    {
        _renderItem : function( ul, item )
        {
            var i = this._super(ul, item);

            // implement custom menu break
            if (item.label == '-')
                i.attr('class', 'ui-menu-divider ui-widget-content');
            else if (item.label.endsWith(SelectMenuLabelBrk))
            {
                i.remove();
                var l = gfRStrip(item.label, SelectMenuLabelBrk);
                var r = "event.stopPropagation();";
                if (ul[0].id == "vault_search_base_path-menu")
                {
                    for (var idx = 0; idx < BookmarkSecretPaths.length; idx++)
                    {
                        if (BookmarkSecretPaths[idx].toLowerCase() == l.toLowerCase())
                            break;
                    }
                    r += 'removeSecretPathSelectBoxItem (' + idx + ');';
                }
                else
                   dbgInfo ("Unknown id : " + ul[0].id  + " in custom.superSelectMenu._renderItem()");

                // construct a new item to replace the one passed in before rendering.
                i = $("<li>").append('<div><span>' + l + '</span><span style="float:right"><a href="#" style="color:red" onclick="' + r + '"><i class="fa fa-map-pin"></i></a></span><div>').appendTo(ul);
            }
            else if ((item.label != ALLOFVAULT) && (ul[0].id == "vault_search_base_path-menu"))
            {            
                // Add pin/unpin feature
                i.remove();
                var l   = item.label;
                var rtnVals = vault_pathURLtoNamePath (l)
                var baseName = l.split(FLDRCHR)[0] + FLDRCHR;
                var basePath = l.split(FLDRCHR).slice(1).join(FLDRCHR);
                var r   = "event.stopPropagation();pinAddRemoveSecretPathSelectBox('" + baseName + "','" + basePath +"');";     
                var col = "darkgreen";                
                for (var idx = 0; idx < BookmarkSecretPaths.length; idx++)
                {
                    if (l == BookmarkSecretPaths[idx])
                    {
                        col = "red";
                        break;
                    }
                }
                
                // construct a new item to replace the one passed in before rendering.
                i = $("<li>").append('<div><span>' + l + '</span><span style="float:right"><a href="#" style="color:' + col + '" onclick="' + r + '"><i class="fa fa-map-pin"></i></a></span><div>').appendTo(ul);
            }
            return i;
        },
    });

    // Link in jquery ui into path super select menu
    $("#vault_search_base_path").superSelectMenu(
    {
        change: function (event, ui)
        {
            var v = $(this).val();

            // jquery bug, and this hack fixes quote chars in values example "systems/blah's secrets/blah"
            if ((ui.item.value != '') && (ui.item.label != ui.item.value))
                v = gfRStrip(ui.item.label, SelectMenuLabelBrk)

            dbgInfo ("#vault_search_base_path:selectmenuchange jump to vault location/url : " + v);
            vaultUIGotoPath (v);
        }
    });

    try
    {
        BookmarkSecretPaths = eval(gfGetCookie ("sp-bookmarks"));
        if (BookmarkSecretPaths == undefined)
            BookmarkSecretPaths = [];
    }
    catch
    {
        BookmarkSecretPaths = [];
    }

    // Set cache loading icon state
    AsyncCacheSetButton ();

    // Set search recyclebin icon state
    SearchRecycleBinSetButton();

    // Load password generator settings
    pwGenerateLoadCookieSettings ();

    // -------------------------------------------
    // Search Box Input Config and Events Handling
    // -------------------------------------------

    // Make search input a combobox without validation, and load saved previous settings
    $("#vault_search").combobox({
        validateData: false,
        select: function (event, ui)
        {
            // get the current selected item text from the option html, and not the value as this will be blank due to quote issues
            // like values 'operator's' that have a quote in the search text
            pinStatusSearchComboBox ($($(this).find("option:selected")[0]).map(function() { return $(this).text(); })[0]);
        },
    });

    // Handle custom focus change
    $("#vault_search").next().find('input').focus(function() {
        $(this).css("background-color", "transparent");     
    });
    
    $("#vault_search").next().find('input').focusout(function() {
        $(this).css("background-color", "");
        $(this).css("color",            ""); 
    });
 
    setTimeout(function ()
    {
        SearchComboBoxLoadCookieSettings();
        $("#vault_search").next().find('input').focus();
    }, 500);

    // link enter key to search action
    $(document).keyup(function(event)
    {            
        if ($("#vault_search").next().find('input').is(":focus"))
        {
            if ((event.ctrlKey || event.shiftKey) && event.key == "Enter")
                runSearch(FLDRCHR);
            else if (event.key == "Enter")
                runSearch();
            else // Update pin icon to show action to pin or not to pin
                pinStatusSearchComboBox ($("#vault_search").next().find('input').val());
        }
        // link to goto secret jump action
        else if ($("#gotosecretpath_input").is(":focus"))
        {
            if (event.key == "Enter")        
            {   
                vaultUIGotoPath (decodeURI($("#gotosecretpath_input").val()));
                $('#gotosecretpath').css('display', 'none');
            }
        }
        
    });
});
</script>

<script>
var MaxTestsForBlankScreenCnt = 0;
function OnLoadIframeStyle ()
{
    dbgInfo ("OnLoadIframeStyle() called!");
    AsyncCacheLoad ();    
    
    setTimeout(function() 
    {
        let testForEmberApp    = document.getElementById(FrameID).contentWindow.document.getElementsByClassName('ember-application');   
        let testForBlankScreen = document.getElementById(FrameID).contentWindow.document.getElementsByClassName('hds-app-frame');   
        
        if (testForEmberApp)
            dbgInfo ("OnLoadIframeStyle() test for blank testForEmberApp == " + testForEmberApp.length);
            
        if (testForBlankScreen)
            dbgInfo ("OnLoadIframeStyle() test for blank testForBlankScreen == " + testForBlankScreen.length);
            
        if (MaxTestsForBlankScreenCnt > 2)
        {
            dbgInfo ("OnLoadIframeStyle() aborting test for blank Screen loop MaxTestsForBlankScreenCnt == " + MaxTestsForBlankScreenCnt);
            MaxTestsForBlankScreenCnt = 0;
            return;
        }
        
        if ((testForEmberApp && testForEmberApp.length > 0) && (testForBlankScreen && testForBlankScreen.length <= 0))
        {                
            dbgInfo ("OnLoadIframeStyle() : detected blank screen, calling frame reload()!");
            document.getElementById(FrameID).contentWindow.location.reload();
            MaxTestsForBlankScreenCnt++;
        }
        else
        {
            dbgInfo ("OnLoadIframeStyle() : page looks to have loaded normally, exiting normally");
        }
    }, 200);  
}
</script>
<script src="js_libs/customisation.js"></script>
<link rel="stylesheet" href="css/customisation.css">
</head>
<body>
<div class="PacifierModal"></div>
<table id="iframe_table" border=0 style="width:100%;height:100%;">
    <!-- main toolbar gui -->
    <tr class="ShowSearchTools">
    <td colspan="100%" style="white-space:nowrap;">        
        <!-- Stupid Hack! this border 0px spacing is required so that search-tools-width actual width can be calculated correctly! -->
        <span id="search-tools-width" style="border: 0px solid red; display:inline-flex;">
            <table border=0><tr style="height: 34px;">
            <td style="white-space: nowrap;" id="cache-status">
                <div style="font-size:9px; position:relative;left:-4; top:-6px;">
                    <a id="cache-async-icon" href="#" onclick="AsyncCacheButtonEvent();"><i class="fa fa-power-off"></i></a>
                </div>
                <div style="top: -5px;position: relative;">
                    <a id="cache-status-icon" class="cache-status-empty" href="#" onclick="chkReqCache (null);noteNorm ('Search Regexp Cache was cleared')" title="Click icon to clear cache!&#10;&#10;Secrets Cache Status:&#10;  Red = no-cache.&#10;  Blue = asynchronous cache loading.&#10;  Green = cache loaded."><i class="fa fa-archive"></i></a>
                </div>
                <span style="width:10px"></span>
            </td>
            <td style="white-space: nowrap;font-family:monospace">
                <span id="vault_search_base_path_style" class="ui-widget">
                     <select id="vault_search_base_path" style="font-family:monospace" title="Limit recursive searching to these areas"></select>
                </span>
                <span id="pin-secret-path-pos" style="font-size:10px;position:relative;top:5px;left:-330px;width:12px;">
                    <a id="pin-secret-path-icon" href="#" onclick="pinAddRemoveSecretPathSelectBox();" title="Pin/Unpin Secret Path"><i class="fa fa-map-pin"></i></a>
                </span>        
                
                <span id="goto-basepath" style="font-size:10px;position:relative;top:-7px;left:-332px;width:12px;margin:-12px">
                    <a id="goto-basepath-icon" href="#" onclick="vaultUIGotoPath('')" title="home"><i class="fa fa-home hover-red"></i></a>
                </span>
                                
                <span id="copy-secret-path" style="font-size:9px;position:relative;top:6px;left:-12px;width:12px;margin:-10px">
                    <a id="copy-secret-path-icon" href="#" onclick="let p = vault_pathURLtoNamePath (VaultCurrentURL); if(p[0]+p[1] == '') { noteError('current path is blank'); return; } gfCopyToClipboard(decodeURI(p[0]+p[1])); noteNorm ('Copied path &quot'+decodeURI(p[0]+p[1])+'&quot to the clipboard')" title="copy current secrets path"><i class=" far fa-clone hover-red"></i></a>
                </span>
                
                <span id="goto-secret-path" style="font-size:9px;position:relative;top:-7px;left:-5px;width:12px;margin:-10px">
                    <a id="goto-secret-path-icon" href="#" onclick=" if ($('#gotosecretpath').css('display') == 'none') {  $('#gotosecretpath').css('display', 'table'); $('#gotosecretpath_input').focus(); } else { $('#gotosecretpath').css('display', 'none') }" title="paste secrets path and goto there"><i class="fas fa-angle-double-right hover-red""></i></a>
                </span>                
                
                <span id="gotosecretpath" style="float:left;display:none;position:fixed;z-index:10" title="paste secrets path, and goto there">
                    <input  id="gotosecretpath_input" type="text" size=50 style="font-family:monospace;" placeholder="paste secrets path, and goto there">
                    <a href="#" style="color:blue;top:6px;left:-35px;position:relative;float:right;font-size:9px" onclick="vaultUIGotoPath ($('#gotosecretpath_input').val());$('#gotosecretpath').css('display', 'none');"><i class="fas fa-angle-double-right hover-red"" title="goto path"></i></a>
                    <a href="#" style="color:blue;top:6px;left:-15px;position:relative;float:right;font-size:9px" onclick="$('#gotosecretpath').css('display', 'none');"><i class="fas fa-times-circle hover-red"" title="close"></i></a>
                </span>                    
                
                <span id="vault_search_style" class="ui-widget">
                  &nbsp;&nbsp;
                </span>                
                
                <span id="vault_search_style" class="ui-widget">
                  <select id="vault_search" type="text" value="" placeholder="Search with regular expressions"></select>
                </span>                
            </td>
            <td style="white-space: nowrap;">
                <div style="font-size:10px;position:relative;left:-302px;width:12px;"> 
                    <a id="pin-search-txt-icon" href="#" onclick="pinAddRemoveSearchComboBox($('#vault_search').next().find('input').val());" title="Pin/Unpin Search String"><i class="fa fa-map-pin"></i></a>
                </div>
            </td>
            <td style="white-space: nowrap;display: flex;">
                <span style="position: relative;width: 8px;left: 8px;top: 19px;font-size:9px;margin:0px">
                    <a id="search-recyclebin-icon" onclick="SearchRecyleBinButtonEvent();" href="#" onclick="" title=""><i class="fas fa-recycle hover-red"></i></a>
                </span>
                <span style="position: relative;width: 8px;left: 0px;top: 5px;font-size: 10px;margin:0px">     
                    <a id="search-clr-icon" onclick="$('#vault_search').next().find('input').val('');$('#vault_search').next().find('input').focus();" href="#" onclick="" title="Clear Search Field"><i class="fas fa-times hover-red"></i></a>
                </span>
            </td>
            <td style="white-space: nowrap" id="search-buts">
                <a id="searchrun-but" href="#" onclick="runSearch();"        title="Recursive Regular Expression Search in -Current Path-&#010&#010Short-cut:&#010    Enter Key"><i class="search-action fas fa-search hover-red"></i></a>
                <a id="searchrun-but" href="#" onclick="runSearch(FLDRCHR);" title="Recursive Regular Expression Search in -All Secrets-&#010&#010Short-cut:&#010    Control or Shift + Enter key">
                    <span class="fa-stack hover-red">
                        <i class="fa fa-search fa-stack-1x" style="color:#5cb3de" ></i>
                        <i class="fa fa-search" style="position: relative; left:9px; top:6px;"></i>
                    </span></a>
                <a id="searchrun-reshow"  href="#" onclick="reshowResultsDialog();" title="Re-show last search results"><i class="search-action fas fa-reply hover-red"></i></a>

                &#x7c;

                <a id="cut-action"        href="#" onclick="cutCopyAction('cut');"                                      title="Cut Current Folder/Item"><i class="search-action fas fa-cut hover-red"></i></a>
                <a id="copy-action"       href="#" onclick="cutCopyAction('copy');"                                     title="Copy Current Folder/Item"><i class="search-action far fa-clone hover-red"></i></a>
                <a id="move-clone-action" href="#" onclick="cloneMoveActionDialog($('#vault_search_base_path').val());" title="Clone/Move/Rename Current Folder/Item"><i class="search-action fas fa-folder hover-red"></i></a>
                <a id="delete-action"     href="#" onclick="nodeDeleteItem (null, $('#vault_search_base_path').val());" title="Delete Current Folder/Item"><i class="search-action fas fa-trash-alt hover-red"></i></a>

                &#x7c;


                <a id="pwGenerator-action"        href="#" onclick="pwGeneratorActionDialog();"                   title="Password Generator">                                                         <i class="fas fa-key hover-red"></i></a>&nbsp;
                <a id="base64-action"             href="#" onclick="base64ToolsActionDialog();"                   title="Base64 Util Encode/Decode Secret&#010URL Unescape/Escape Data">              <i class="fas fa-tools hover-red"></i></a>&nbsp;
                <a id="progInfo-action"           href="#" onclick=";"                                            title="Programmer REST API Example Code&#010Goto a secret leaf node to activate">   <i class="fas fa-laptop-code hover-red"></i></a>&nbsp;
                <a id="vaultAPIExplorer"          href="#" onclick="vaultUIGotoURI('/vault/tools/api-explorer');" title="Programmer Vault API REST Explorer">                                         <i class="fas fa-code hover-red"></i></a>&nbsp;                
                <a id="rootTools-action"          href="#" onclick="rootToolsActionDialog();"                     title="Root Token Generator/Revoker">                                               <i class="fas fa-code-branch fa-rotate-180 hover-red"></i></a>&nbsp;

                <a id="domainUsersGroups-action" href="#"  onclick="domainUsersGroupsActionDialog();"             title="AD/LDAP Domain Users/Groups Builder&#010Requires ROOT access/token">         <i class="fas fa-users-cog hover-red"></i></a>&nbsp;
                <a id="vault-expimp-action"       href="#" onclick="vaultExportImport_JSONFormatActionDialog();"  title="Export/Import Secrets from/into JSON format&#010Requires ROOT access/token"> <i class="fas fa-file-code hover-red"></i></a>&nbsp;
                
                &#x7c;

                <a id=""                          href="#" onclick="let p = vault_pathURLtoNamePath (VaultCurrentURL); vaultDoDeepLinkURL (decodeURI(p[0]+p[1]));"     title="Copy Deep Link URL Folder Path into Clipboard"><i class="fas fa-external-link-alt"></i></a>&nbsp;
                
                <a id=""                          href="#" onclick="noteNorm(AUTHOR, 8000);"    title="About Vault GUI Helper"><i class="fas fa-info-circle hover-red"></i></a>&nbsp;
                <a id=""                          href="/ui"                                    title="No GUI Helper"><i class="fas fa-window-close hover-red"></i></a>&nbsp;

            </td>
            <td class="search-busy" style="display:none; white-space: nowrap;">
                <img src="css/busy.gif" style="width:16px;height:16px" alt="busy">
            </td>
            <td class="search-busy" style="display:none; padding-left:10px;padding-right:10px; white-space: nowrap;">
                <a id="search-abort"    style="color:red !important" href="#" onclick="vaultAbortAction();" title="Abort Action!"><i class="fas fa-exclamation"></i></a>
            </td>
            </tr>
            </table>
        </span>
    </td>
    </tr>

    <tr id="clipCutCopyView" style="visibility:collapse;display:none">
       <td>
       <div  class="ShowSearchTools" style="max-height:100px;overflow-y:scroll;">
       <table><tr style="vertical-align:top">
            <td style="border-right: black;border-right-width: 1px;border-right-style: solid;">
                <a id="paste-action"   href="#" onclick="pasteAction();"   title="Paste Folder/Item into Current Folder"><i class="search-action fas fa-brush hover-red"></i></a>
                <a id="clrclip-action" href="#" onclick="clrClipAction();" title="Clear current Cut/Copy action"><i class="search-action fas fa-broom hover-red"></i></a>
            </td>
            <td id="clipOperation" style="font-size:20px;position: relative;top: -6px;"></td>
            <td style="position: relative;top: -4px;">:</td>
            <td id="clipVaultSrcPath" style='white-space: pre;'></td>
            <td style="font-size:30px; position: relative;top: -13px;">&#x21d2;</td><td id="clipVaultDestPath"></td>
       </tr></table>
       </div>
       </td>
    </tr>

    <tr style="visibility:collapse;height:0px"><td>
        <span id="userNoteNorm" style="z-index:200"></span>
        <span id="userNoteErr" style="z-index:200"></span>
    </td></tr>

    <!-- all of the dynamically displayed dialog box templates -->
    <tr style="visibility:collapse;display:none"><td>
        
        <!-- ############################################################################################################ -->
        
        <div id="searchDialog">
            <table border=0 style="position:fixed;z-index:100;white-space: nowrap;vertical-align: middle;">
                <tr>
                <td style="white-space: nowrap;">
                    <span style="font-weight:bold;font-size: 12px">Filter: </span>
                    <input type="text" id="subSearchOutput" value="" style="font-family:monospace;">
                </td>
                <td style="white-space: nowrap;font-size: 14px; vertical-align: middle;">
                    <a href="#"><i id="search-onoff-chkboxs" onclick="onOffActionCheckBoxSearch()" title="Turn on/off multi-select checkbox cut/copy/delete tree operations" class="search-chkboxs-syle  fas fa-toggle-off hover-red"></i></a>
                </td>
                <td id="search-chkboxs-controls" style="display:none;white-space: nowrap;font-size: 14px; vertical-align: middle;">
                    <a id="search-chkboxs-cut-action"    href="#" onclick="cutCopyDelActionCheckBoxSearch('cut-chkbox');"  title="Cut Selected Folder/Item"><i class="search-chkboxs-syle fa fa-cut hover-red"></i></a>
                    <a id="search-chkboxs-copy-action"   href="#" onclick="cutCopyDelActionCheckBoxSearch('copy-chkbox');" title="Copy Selected Folder/Item"><i class="search-chkboxs-syle  far fa-clone hover-red"></i></a>
                    <a id="search-chkboxs-delete-action" href="#" onclick="cutCopyDelActionCheckBoxSearch('del-chkbox');"  title="Delete Selected Folder/Item"><i class="search-chkboxs-syle fas fa-trash-alt hover-red"></i></a>
                </td>
                </tr>
            </table>
            <div style="font-family:monospace;width:100%;height:27px;">&nbsp;</div>
            <div id="searchOutput" style="min-width:350px; font-family:monospace !important; font-size:medium !important;"></div>
        </div>

        <!-- ############################################################################################################ -->

        <div id="dumpSearchTreeToJSONDialog">
            <div id="dumpSearchTreeToJSONOutput" style="font-family:monospace !important; font-size:medium !important;"></div>
        </div>

        <!-- ############################################################################################################ -->

        <div id="deleteDialog">
            <div id="deleteToRecycleBin" style="z-index:120;width:100%;font-family:monospace !important; font-size:medium !important;">
                <table style="width:100%" border=0><tr><td>
                <fieldset style="padding:0px;margin:0px;border-radius:4px;border-width:1px;padding-left: 2px;">
                    <table border=0>
                        <tr>
                            <td style="white-space:nowrap;width:fit-content"><input type="checkbox" id="deleteToRecycleChk" value="checked">Move Deleted Items to Recycle Bin(s)</td>
                        </tr>
                    </table>
                </fieldset>
                </td></tr></table>
            </div>
            
            <div id="deleteSearchOutput" style="font-family:monospace !important; font-size:medium !important;"></div>
        </div>

        <!-- ############################################################################################################ -->

        <div id="folderSelectDialog">
            <div id="folderSelectOutput" style="font-family:monospace !important; font-size:medium !important;"></div>
        </div>
        
        <!-- ############################################################################################################ -->

        <div id="deleteConfirmDialog">
            <table style="width:100%;height:100%">
                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td style="white-space: nowrap;">Enter <b>DELETE</b> to confirm:</td>
                    <td><input type="text" id="deleteConfirmFld" class="text ui-widget-content ui-corner-all"/></td>
                </tr>
            </table>
        </div>

        <!-- ############################################################################################################ -->

        <div id="cloneMoveDialog" style="font-size:10px">
            <table style="width:100%;height:100%" border=0>
                <tr>
                    <td style="font-size:10px;">
                         <fieldset  style="padding: 5px;">
                            <legend>Operation Type: </legend>
                            <label for="radio-clone"       style="width:100px;text-align:left;">Clone</label>      <input type="radio" name="radio-1" id="radio-clone"><br>
                            <label for="radio-move-rename" style="width:100px;text-align:left;">Move/Rename</label><input type="radio" name="radio-1" id="radio-move-rename">
                          </fieldset>
                     </td>
                     <td style="width:100%">
                        <table style="width:100%;height:100%" border=0>
                            <tr>
                                <td style="white-space:nowrap;width:fit-content">Source Folder:</td>
                                <td style="width:100%"><input  size="80" style="width:100%;font-family:monospace" type="text" id="cloneMoveSrcld"        class="text ui-widget-content ui-corner-all"/></td>
                                <td style="white-space:nowrap;width:fit-content"><button class="ui-button ui-corner-all ui-widget" onclick="nodeSelectFolderInput('#cloneMoveDialog', '#cloneMoveSrcld',  $('#cloneMoveSrcld').val(), '#cloneMoveSrcFldrSelld', 1)"><i id="cloneMoveSrcFldrSelld" class="fas fa-angle-double-right" style="text-decoration:none;"></i></button></td>
                            </tr>

                            <tr>
                                <td style="white-space:nowrap;width:fit-content">Destination Folder:</td>
                                <td style="width:100%"><input  size="80" style="width:100%;font-family:monospace" type="text" id="cloneMoveDestld"        class="text ui-widget-content ui-corner-all"/></td>
                                <td style="white-space:nowrap;width:fit-content"><button class="ui-button ui-corner-all ui-widget" onclick="nodeSelectFolderInput('#cloneMoveDialog', '#cloneMoveDestld',  $('#cloneMoveDestld').val(),'#cloneMoveDestFldrSelld', 1)"><i id="cloneMoveDestFldrSelld" class="fas fa-angle-double-right" style="text-decoration:none;"></i></button></td>
                            </tr>
                        </table>
                     </td>
                </tr>
                <tr style="height:100%"><td></td></tr>
            </table>
        </div>

        <!-- ############################################################################################################ -->

        <div id="codeGenSrc"></div>

        <!-- ############################################################################################################ -->

        <div id="codeGenSrcDialog"></div>

        <!-- ############################################################################################################ -->

        <div id="copyPasteAddReplaceDialog" style="font-size: medium;padding-block: 20px;padding-left: 20px;padding-right: 20px;">
             <div>Do you want to <b>Add</b> or <b>Replace</b> existing <b>Cut/Copy</b> path</div>
        </div>

        <!-- ############################################################################################################ -->

        <div id="base64ToolsDialog" style="font-size:10px">
            <table style="width:100%;height:50%" border=0>
                <tr>
                    <td style="white-space:nowrap">
                        Base64 Data to:
                    </td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="$('#textarea_base64output').val(atob($('#textarea_base64').val()));"                                style='font-family:monospace;width:100%'>Decode Input &rarr; Output</button>
                    </td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="$('#textarea_base64output').val(btoa($('#textarea_base64').val()));"                                style='font-family:monospace;width:100%'>Encode Input &rarr; Output</button>
                    </td>
                </tr>
                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="gfDownload (atob($('#textarea_base64').val()), 'VaultSecretData.Bin', 'application/octet-stream');" style='font-family:monospace;width:100%'>Decode Input &rarr; Binary File</button>
                    </td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="gfOpenFile (function (contents){ $('#textarea_base64output').val(btoa(contents)) });"               style='font-family:monospace;width:100%'>Encode Binary File &rarr; Output</button>
                    </td>
                </tr>
                <tr><td colspan="100%"><hr></td></tr>
                <tr>
                    <td style="white-space:nowrap">
                        URI Encode Data to:
                    </td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="$('#textarea_base64output').val(decodeURI($('#textarea_base64').val()));"                            style='font-family:monospace;width:100%'>decodeURI Input &rarr; Output</button>
                    </td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="$('#textarea_base64output').val(encodeURI($('#textarea_base64').val()));"                              style='font-family:monospace;width:100%'>encodeURI Input &rarr; Output</button>
                    </td>
                </tr>
                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="gfDownload (decodeURI($('#textarea_base64').val()), 'VaultSecretData.Bin', 'application/octet-stream');" style='font-family:monospace;width:100%'>decodeURI Input &rarr; Binary File</button>
                    </td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="gfOpenFile (function (contents){ $('#textarea_base64output').val(encodeURI(contents)) });"               style='font-family:monospace;width:100%'>encodeURI Binary File &rarr; Output</button>
                    </td>
                </tr>
                <tr><td colspan="100%"><hr></td></tr>
                <tr>
                    <td style="white-space:nowrap">
                        JSON Operations on Data:
                    </td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="$('#textarea_base64output').val('');$('#textarea_base64output').val( JSON.stringify (JSON.parse($('#textarea_base64').val()), null, 4) );"  style='font-family:monospace;width:100%'>Format/Validate JSON Input &rarr; Output</button>
                    </td>
                </tr>
                <tr><td colspan="100%"><hr></td></tr>
                <tr>
                     <td style="width:100%;height:100%" colspan="100%">
                        <table style="width:100%;height:100%" border=0>
                            <tr><td><a href="#" onclick="$('#textarea_base64').val('');" title="Clear Input"><i class="fas fa-broom hover-red"></i></a> Input:</td></tr>
                            <tr><td height="100%"><textarea id="textarea_base64" cols="40" rows="10" style="font-family:monospace;width:100%;height:100%"></textarea></td></tr>
                        </table>
                     </td>
                </tr>
           </table>
           <table style="width:100%;height:50%" border=0>
                <tr>
                     <td style="width:100%;height:100%">
                        <table style="width:100%;height:100%" border=0>
                            <tr><td>
                                    <a href="#" onclick="$('#textarea_base64output').val('');" title="Clear Output"><i class="fas fa-broom hover-red"></i></a>
                                    <a title='Copy Output to Clipboard' class='fas fa-copy hover-red' onclick="gfCopyToClipboard($('#textarea_base64output').val()); noteNorm('Output copied to Clipboard');" href='#'></a>
                                    Output:
                            </td></tr>
                            <tr>
                                <td height="100%"><textarea id="textarea_base64output" cols="40" rows="10" style="font-family:monospace;width:100%;height:100%"></textarea></td>
                            </tr>
                        </table>
                     </td>
                </tr>
            </table>
        </div>

        <!-- ############################################################################################################ -->

        <div id="pwGeneratorDialog" style="font-size:10px;">
            <table style="width:600px;height:100%" border=0>

                <tr>
                    <td style="white-space:nowrap">
                        ASCII Length of password:
                    </td>
                    <td style="white-space:nowrap">
                        <input type="number" id="pwgen-pwASCIILen" min="4" max="1024" value="16">
                     </td>
                </tr>

                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <input type="checkbox" id="pwgen-pwASCIIUppercase" checked>Upper-Case (A, B, C, ...)
                    </td>
                    <td style="white-space:nowrap">
                        <input type="checkbox" id="pwgen-pwASCIILowercase" checked>Lower-Case (a, b, c, ...)
                    </td>
                    <td style="width:100%"></td>
                </tr>

                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <input type="checkbox" id="pwgen-pwSpaces">Spaces ( )
                    </td>
                    <td style="white-space:nowrap">
                        <input type="checkbox" id="pwgen-pwSpecials">Specials (!, $, %, &, -, +, ...)
                    </td>
                    <td style="width:100%"></td>
                </tr>

                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <input type="checkbox" id="pwgen-pwDigits" checked>Digits (0, 1, 2, ... )
                    </td>
                    <td style="white-space:nowrap">
                        <input type="checkbox" id="pwgen-pwBrackets">Brackets ([, ], {, }, (, ), &lt;. &gt;)
                    </td>
                    <td style="width:100%"></td>
                </tr>

                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="pwGenerate('ascii');" style='font-family:monospace;width:100%'>Generate ASCII Password</button>
                    </td>
                    <td style="width:100%"></td>
                </tr>

                <tr>
                    <td style="white-space:nowrap" colspan="100%"><hr></td>
                </tr>


                <tr>
                    <td style="white-space:nowrap">
                        HEX Length of password:
                    </td>
                    <td style="white-space:nowrap">
                        <input type="number" id="pwgen-pwHexLen" min="4" max="1024" value="16">
                     </td>
                </tr>
                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <input type="radio" id="pwgen-pwHEXUppercase" name="pwgen-hexCase" value="upper" checked>Upper-Case (A1, B2, C3, ...)
                    </td>
                    <td style="width:100%"></td>
                </tr>
                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <input type="radio" id="pwgen-pwHEXLowercase" name="pwgen-hexCase" value="lower">Lower-Case (a1, b2, c3, ...)
                    </td>
                    <td style="width:100%"></td>
                </tr>
                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <input type="radio" id="pwgen-pwHEXLowercase" name="pwgen-hexCase" value="both">Both-Case (a1, B2, c3, ...)
                    </td>
                    <td style="width:100%"></td>
                </tr>

                <tr>
                    <td></td>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="pwGenerate('hex');" style='font-family:monospace;width:100%'>Generate HEX Password</button>
                    </td>
                    <td style="width:100%"></td>
                </tr>

                <tr>
                    <td style="white-space:nowrap" colspan="100%"><hr></td>
                </tr>

                <tr>
                    <td style="width:100%;height:100%" colspan="100%">
                        <table style="width:100%;height:100%" border=0>
                            <tr><td style="white-space:nowrap">
                                    <a href="#" onclick="$('#textarea_pwgeneratorOutput').val('');" title="Clear Output"><i class="fas fa-broom hover-red"></i></a>
                                    <a title='Copy Output to Clipboard' class='fas fa-copy hover-red' onclick="gfCopyToClipboard($('#textarea_pwgeneratorOutput').val()); noteNorm('Output copied to Clipboard');" href='#'></a>
                            </td>
                            <td style="width:100%;text-align:right;">
                                <input type="checkbox" id="pwgen-pwAutoCopyGenPW" checked>Auto Copy genrated password into clipboard
                            </td>
                            </tr>
                            <tr>
                                <td height="100%" colspan="100%"><textarea id="textarea_pwgeneratorOutput" cols="40" rows="10" style="font-family:monospace;width:100%;height:100%"></textarea></td>
                            </tr>
                        </table>
                     </td>
                </tr>
           </table>
        </div>

        <!-- ############################################################################################################ -->
        
        <div id="pwRootToolsDialog" style="font-size:10px;">
            <table style="width:100%;height:100%" border=0>
            <tr><td style="width:100%">
                <table style="width:100%;font-family:monospace;" border=0>
                <tr>
                    <td style="white-space:nowrap" colspan=2>
                        <u>Root Token Generation</u>
                    </td>
                </tr>
                <tr>
                    <td style="white-space:nowrap;vertical-align: top;">
                        Enter Vault Recovery Keys:
                    </td>
                    <td style="white-space:nowrap;text-align:left;width:100%;">
                        <table style="width:100%;height:100%;" border=0 id="pwRootToolsSealNumReq"><tbody></tbody></table>
                    </td>
                </tr>
                <tr>
                    <td style="white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" style="font-family:monospace" onclick="rootGenerateToken();">Generate Root Token</button>
                    </td>
                    <td style="white-space:nowrap">
                        <input type="checkbox" id="pwRoot-AutoLogin" checked="">Auto Login with Root Token
                    </td>
                </tr>
                </table>

                <hr>

                <table style="width:100%;text-align:left;font-family:monospace;" border=0>
                <tr>
                    <td><u>Current Root Tokens:</u><div style="font-size:small">These should be <b>revoked</b> after use! Requires <b>root access</b> to view this list</div></td>
                </tr>
                </table>
                <table style="width:100%;text-align:left;font-family:monospace;" border=0 id="pwRootToolsCurrentRootTokens">
                <tr style="text-decoration:underline;white-space:nowrap;background-color: lightgrey;">
                    <th><input type="checkbox" id="pwRoot-CheckAll" onclick="$('[id*=pwRoot-Check-Token-]').each(function(idx){$(this).prop('checked', $('#pwRoot-CheckAll').prop('checked'));});">All</th><th>Name</th><th>Creation Time</th><th>Expiration Time</th><th>Policies</th><th>Token Accessor</th>
                </tr>
                </table>
            </td></tr>

            <tr>
                <td style="white-space:nowrap;vertical-align: top;font-family:monospace">
                    <hr>
                    <table style="width:100%;height:100%;font-family:monospace;" border=0>
                        <tr>
                            <td style="white-space:nowrap;width:100%"><input type="text" id="sudo-token-login" max="1024" style="width:100%;font-family: monospace;"></td>
                            <td style="white-space:nowrap"><button class="ui-button ui-corner-all ui-widget" onclick="BecomeAsTokenWrapper ($('#sudo-token-login').val());" style="font-family:monospace">Become as Token</button></td>
                        </tr>
                    </table>
                </td>
            </tr>

            <tr>
                 <td style="width:100%;height:100%">
                    <table style="width:100%;height:100%" border=0>
                    <tr>
                        <td>
                            <a href="#" onclick="$('#textarea_pwRootToolsoutput').val('');" title="Clear Output"><i class="fas fa-broom hover-red"></i></a>
                            <a title='Copy Output to Clipboard' class='fas fa-copy hover-red' onclick="gfCopyToClipboard($('#textarea_pwRootToolsoutput').val()); noteNorm('Output copied to Clipboard');" href='#'></a>
                            Output:
                    </td>
                    </tr>
                    <tr>
                        <td height="100%"><textarea id="textarea_pwRootToolsoutput" cols="40" rows="10" style="font-family:monospace;width:100%;height:100%"></textarea></td>
                    </tr>
                    </table>
                 </td>
            </tr>
           </table>
        </div>

        <!-- ############################################################################################################ -->
        
        <div id="createDomainUsersGroupsDialog" style="font-size:10px;">
            <table style="width:100%;height:100%" border=0>
            <tr><td style="width:100%">
                <table style="width:100%;height:100%;font-family:monospace;" border=0>
                
                <tr>
                    <td style="white-space:nowrap;vertical-align: top;">
                        <label id="ugDomainOfEntityLbl" for="ugDomainNameOfEntity">Enter <b><span id="ugDomainNameOfEntityLbl_type">Domain  Name</span></b>:</label>
                    </td>
                    <td>
                        <input type="input" id="ugDomainNameOfEntity" placeholder="Enter AD/LDAP Domain name" style="display:table-cell;width:100%;background-color:#CFC503;">
                    </td>
                </tr>
                
                <tr><td colspan="100%"><hr></td></tr>
                
                <tr>
                    <td style="white-space:nowrap" colspan="100%">
                        <u>Add AD/LDAP Users/Groups to Vault</u>
                    </td>
                </tr>

                <tr>
                    <td style="white-space:nowrap;vertical-align: top;">
                        <label for="ugSelection">Build Mode:</label>
                    </td>
                    <td style="white-space:nowrap;">
                        <input type="radio" id="ugGroupMode" name="ugSelection" value="group" onclick="$('#ugNameOfEntityLbl_type').html('AD Group')"><Label for="ugGroupMode">Domain <b>AD/LDAP Group</b></label>
                    </td>
                </tr>

                <tr>
                    <td></td>
                    <td style="white-space:nowrap;">
                        <input type="radio" id="ugUserMode"  name="ugSelection" value="user"  onclick="$('#ugNameOfEntityLbl_type').html('AD User')"><Label for="ugUserMode">Domain <b>AD/LDAP User</b></label>
                    </td>
                </tr>

                <tr>
                    <td style="white-space:nowrap;vertical-align: top;">
                        <label id="ugNameOfEntityLbl" for="ugNameOfEntity">Enter Domain <b><span id="ugNameOfEntityLbl_type">AD/LDAP User or Group</span></b>:</label>
                    </td>
                    <td>
                        <input type="input" id="ugNameOfEntity" placeholder="User, or Group to grant access" onkeyup="$('#ugMountPointOfEntity').val($('#ugNameOfEntity').val())" style="display:table-cell;width:100%;background-color:#b4caff;">
                    </td>
                </tr>

                <tr>
                    <td style="white-space:nowrap;vertical-align: top;">
                        <label id="ugMountPointOfEntityLbl" placeholder="Secrets mount point to create, or existing mount point" for="ugMountPointOfEntity">Enter Mount Point Name:</label>
                    </td>
                    <td>
                        <input type="input" id="ugMountPointOfEntity" placeholder="if it differs from User, or Group" style="display:table-cell;width:100%;background-color:#b4caff;">
                    </td>
                </tr>

                <tr>
                    <td style="white-space:nowrap;vertical-align: top;">
                        <label>Authentication Method:</label>
                    </td>
                    <td style="white-space:nowrap;">
                        <input type="checkbox" id="ugAuthLDAP" checked><label for="ugAuthLDAP">LDAP/Active Directory<label>
                    </td>
                </tr>

                <tr>
                    <td></td>
                    <td style="white-space:nowrap;">
                        <input type="checkbox" id="ugAuthOIDC" checked><label for="ugAuthOIDC">OIDC/SAML (Single Sign On)<label>
                    </td>
                </tr>
                <tr>
                    <td></td>
                    <td style="text-align:right;white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="domainUsersGroupsAdd($('#ugDomainNameOfEntity').val())" style="font-family:monospace;color:white;background-color:blue;width:120px;">Add Access</button>
                    </td>
                </tr>

                <tr><td colspan="100%"><hr></td></tr>
                <tr>
                    <td style="white-space:nowrap" colspan="100%">
                        <u>Remove Domain AD/LDAP Users/Groups from Vault</u>
                    </td>
                </tr>


                <tr>
                    <td style="white-space:nowrap;vertical-align: top;">
                        <label id="ugRemoveNameOfEntityLbl" for="ugRemoveNameOfEntity">Enter Domain <b>AD User or Group</b>:</label>
                    </td>
                    <td>
                        <input type="input" id="ugRemoveNameOfEntity" placeholder="User, or Group to remove access" onkeyup="$('#ugRemoveMountPointOfEntity').val($('#ugRemoveNameOfEntity').val())" style="display:table-cell;width:100%;background-color:#f2b9b9;">
                    </td>
                </tr>

                <tr>
                    <td style="white-space:nowrap;vertical-align: top;">
                        <label id="ugRemoveMountPointOfEntityLbl" placeholder="Secrets mount point to remove access" for="ugRemoveMountPointOfEntity">Enter Mount Point Name:</label>
                    </td>
                    <td>
                        <input type="input" id="ugRemoveMountPointOfEntity" placeholder="if it differs from User, or Group" style="display:table-cell;width:100%;background-color:#f2b9b9;">
                    </td>
                </tr>

                <tr>
                    <td></td>
                    <td style="text-align:right;white-space:nowrap">
                        <button class="ui-button ui-corner-all ui-widget" onclick="domainUsersGroupsRemoveConfirm($('#ugDomainNameOfEntity').val())" style="font-family:monospace;color:white;background-color:red;width:120px;">Remove Access</button>
                    </td>
                </tr>

                </table>
            </td></tr>

            <tr><td style="width:100%;height:100%">
                <table style="width:100%;height:100%" border=0>
                <tr>
                    <td>
                        <a href="#" onclick="$('#textarea_usersGroupsOutput').val('');" title="Clear Output"><i class="fas fa-broom hover-red"></i></a>
                        <a title='Copy Output to Clipboard' class='fas fa-copy hover-red' onclick="gfCopyToClipboard($('#textarea_usersGroupsOutput').val()); noteNorm('Output copied to Clipboard');" href='#'></a>
                        Output:
                    </td>
                </tr>
                <tr>
                    <td height="100%"><textarea id="textarea_usersGroupsOutput" cols="80" rows="15" style="font-family:monospace;width:100%;height:100%;white-space:pre" readonly></textarea></td>
                </tr>
                </table>
            </td></tr>

            </table>
        </div>

        <!-- ############################################################################################################ -->
        
        <div id="removeConfirmDialog">
            <table style="width:100%;height:100%">
                <tr><td>&nbsp;</td></tr>
                <tr>
                    <td style="white-space: nowrap;">Enter <b>Remove</b> to confirm:</td>
                    <td><input type="text" id="removeConfirmFld" class="text ui-widget-content ui-corner-all"/></td>
                </tr>
            </table>
        </div>
        
        <!-- ############################################################################################################ -->
       
        <div id="exportImportJSONDialog" style="font-size:10px;">
            <table style="width:100%;height:100%" border=0>
            <tr><td style="width:100%">
                <table style="width:100%;height:100%;font-family:monospace;" border=0>
                <tr>
                    <td style="white-space:nowrap" colspan="100%">
                        <u>Export Secrets from Vault:</u>
                    </td>
                </tr>                
                <tr> 
                    <td style="white-space:nowrap;width:fit-content" colspan="100%"> 
                        <table style="width:100%"><tr>
                            <td style="width:100%">
                                <input type="input" id="expimpSecretExpPath" placeholder="Secrets mount point & path to export to JSON" style="display:table-cell;width:100%;background-color:#b4caff;">
                            <td>
                            <td style="text-align:right;white-space:nowrap">
                                <button class="ui-button ui-corner-all ui-widget" onclick="nodeSelectFolderInput('#exportImportJSONDialog', '#expimpSecretExpPath',  $('#expimpSecretExpPath').val(), '#expimpFldrSelld', 1)"><i id="expimpFldrSelld" class="fas fa-angle-double-right" style="text-decoration:none;"></i></button></td>
                            </td>
                        </tr></table>
                    </td>
                    <td></td>                    
                </tr>
                
                <tr>
                    <td style="text-align:left;white-space:nowrap">                        
                    </td>
                    <td style="text-align:right;white-space:nowrap">                        
                        <button class="ui-button ui-corner-all ui-widget" onclick="vaultExportInput_IMP_JSON ('#textarea_expimp_inout');" style="font-family:monospace;color:white;background-color:red;width:120px;">Import Secrets</button>
                        <button class="ui-button ui-corner-all ui-widget" onclick="vaultExportInput_Help_JSON();"                         style="font-family:monospace;color:white;background-color:darkcyan;width:160px;">Import Format Help</button>
                        <button class="ui-button ui-corner-all ui-widget" onclick="vaultExportInput_EXP_JSON ($('#expimpSecretExpPath').val(), '#textarea_expimp_inout');" style="font-family:monospace;color:white;background-color:blue;width:120px;">Export Secrets</button>
                    </td>
                </tr>
                
                <tr>
                    <td style="text-align:right;white-space:nowrap" colspan="100%">
                        <hr>
                    </td>
                </tr>      
                

                </table>
            </td></tr>

            <tr><td style="width:100%;height:100%">
                <table style="width:100%;height:100%" border=0>
                <tr>
                    <td>
                        <a href="#" onclick="$('#textarea_expimp_inout').val('');" title="Clear Output"><i class="fas fa-broom hover-red"></i></a>
                        <a title='Copy Output to Clipboard' class='fas fa-copy hover-red' onclick="gfCopyToClipboard($('#textarea_expimp_inout').val()); noteNorm('Output copied to Clipboard');" href='#'></a>
                        JSON Input/Output:
                    </td>
                </tr>
                <tr>
                    <td height="100%"><textarea id="textarea_expimp_inout" cols="80" rows="15" style="font-family:monospace;width:100%;height:100%;white-space:pre"></textarea></td>
                </tr>
                </table>
            </td></tr>

            <tr><td style="width:100%;height:auto">
                <table style="width:100%;height:auto" border=0>
                <tr>
                    <td>
                        <a href="#" onclick="$('#textarea_expimp_logout').val('');" title="Clear Output"><i class="fas fa-broom hover-red"></i></a>
                        <a title='Copy Output to Clipboard' class='fas fa-copy hover-red' onclick="gfCopyToClipboard($('#textarea_expimp_logout').val()); noteNorm('Output copied to Clipboard');" href='#'></a>
                        Process Log Output:
                    </td>
                </tr>
                <tr>
                    <td height="100%"><textarea id="textarea_expimp_logout" cols="80" rows="5" style="font-family:monospace;width:100%;height:100%;white-space:pre" readonly></textarea></td>
                </tr>
                </table>
            </td></tr>
            
            </table>
        </div>
        
        <!-- ############################################################################################################ -->

    </td></tr>    

    <tr height="100%"><td>
        <iframe id="vaultIFrame" onload="OnLoadIframeStyle();" src=''>
    </td></tr>
</table></body></html>